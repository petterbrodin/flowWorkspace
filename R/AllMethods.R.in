#TODO Fix the messed up encoding of quadrant gate names (it works but it's not pretty when it prints)
setMethod("openWorkspace",signature=signature(file="character"),definition= function(file){
 	message("We do not fully support all features found in a flowJo workspace, nor do we fully support all flowJo workspaces at this time.")
	if(inherits(file,"character")){
		x<-xmlTreeParse(file,useInternal=TRUE);
	}else{
		stop("Require a filename of a workspace, but received ",class(x)[1]);
	}
	ver<-xpathApply(x,"/Workspace",function(x)xmlGetAttr(x,"version"))[[1]]
	x<-new("flowJoWorkspace",version=ver,.cache=new.env(parent=emptyenv()),file=basename(file),path=dirname(file),doc=x)
	x@.cache$flag=TRUE;
	return(x);
})

setAs("list", "GatingSet", function(from, to ){
	if(!all(unlist(lapply(from,function(y)class(y)=="GatingHierarchy"),use.names=FALSE))){
		stop("Can't coerce this list to class GatingSet");
	}
	new(to, set=from)
})

setMethod("edgeMatrix",signature=c("GatingHierarchy"),function(object){
graph::edgeMatrix(object@tree)
})
setMethod("edgeMatrix",signature=c("GatingSet"),function(object){
lapply(object,edgeMatrix)
})

setMethod("haveSameGatingHierarchy",signature=c("GatingSet","missing"),function(object1,object2=NULL){
	em<-edgeMatrix(object1)
	if(length(em)>=2){
		return(all(sapply(2:length(em),function(i)identical(em[[1]],em[[i]])))& all(apply(do.call(cbind,lapply(object1,function(x)gsub("^.*\\.","",RBGL:::bfs(x@tree)))),1,function(x)x%in%x[1])))
	}else{
		return(TRUE)
	}
})


splitGatingSetByNgates<-function(x){
    flowCore:::checkClass(x,"GatingSet");
    pData(x)$ngates<-unlist(lapply(x,function(x)length(x@nodes)))
    #cluster by number of gates.. set up the groups
    groups<-by(pData(x),pData(x)$ngates,function(x)as.numeric(rownames(x)))
    #split the data
    x<-lapply(groups,function(y){
        x[y]
    })
    x
}


setMethod("haveSameGatingHierarchy",signature=c("GatingSet","GatingSet"),function(object1,object2){
	em<-c(edgeMatrix(object1),edgeMatrix(object2))
	all(sapply(2:length(em),function(i)identical(em[[1]],em[[i]])))& all(apply(do.call(cbind,c(lapply(object1,function(x)gsub("^.*\\.","",RBGL:::bfs(x@tree))),lapply(object2,function(x)gsub("^.*\\.","",RBGL:::bfs(x@tree))))),1,function(x)x%in%x[1]))
})


setMethod("haveSameGatingHierarchy",signature=c("GatingSet","GatingHierarchy"),function(object1,object2){
	em<-c(edgeMatrix(object1),list(edgeMatrix(object2)))
	all(sapply(2:length(em),function(i)identical(em[[1]],em[[i]])))&all(apply(do.call(cbind,c(lapply(object1,function(x)RBGL:::bfs(x@tree)),list(RBGL:::bfs(object2@tree)))),1,function(x)x[1]%in%x))
})


setMethod("haveSameGatingHierarchy",signature=c("GatingHierarchy","GatingSet"),function(object1,object2){
	em<-c(edgeMatrix(object2),list(edgeMatrix(object1)))
	all(sapply(2:length(em),function(i)identical(em[[1]],em[[i]])))&all(apply(do.call(cbind,c(lapply(object2,function(x)RBGL:::bfs(x@tree)),list(RBGL:::bfs(object1@tree)))),1,function(x)x[1]%in%x))
})
setMethod("haveSameGatingHierarchy",signature=c("GatingHierarchy","GatingHierarchy"),function(object1,object2){
	identical(edgeMatrix(object1),edgeMatrix(object2))&all(apply(cbind(gsub("^.*\\.","",RBGL:::bfs(object1@tree)),gsub("^.*\\.","",RBGL:::bfs(object2@tree))),1,function(x)x[1]%in%x))
})

setMethod("haveSameGatingHierarchy",signature=c("list","missing"),function(object1,object2=NULL){
	if(!all(do.call(c,lapply(object1,class))%in%"GatingSet")&!all(do.call(c,lapply(object1,class))%in%"GatingHierarchy"))
		stop("object must be a list of GatingSet or GatingHierarchy objects")
	em<-lapply(object1,edgeMatrix)
	if(length(em)>=2){
		return(all(sapply(2:length(em),function(i)identical(em[[1]],em[[i]]))))
	}else{
		return(TRUE)
	}
})

setMethod("show",signature("flowJoWorkspace"),function(object){
	cat("FlowJo Workspace Version ",object@version,"\n");
	cat("File location: ",object@path,"\n");
	cat("File name: ",object@file,"\n");
	if(object@.cache$flag){
		cat("Workspace is open.","\n");
		cat("\nGroups in Workspace\n");
		tbl<-table(Name=getSampleGroups(object)$groupName,GroupID=getSampleGroups(object)$groupID)
		print(data.frame(Name=rownames(tbl),"Num.Samples"=diag(tbl)))
	}else{	
		cat("Workspace is closed.","\n")
	}
})


setMethod("closeWorkspace","flowJoWorkspace",function(workspace){
	free(workspace@doc);
	workspace@.cache$flag<-FALSE;
})
setOldClass("summary")

setMethod("summary",signature("flowJoWorkspace"),function(object,...){
	show(object,...);
})

setMethod("parseWorkspace",signature("flowJoWorkspace"),function(obj,name=NULL,execute=TRUE,isNcdf=FALSE,subset=NULL,nslaves=4,requiregates=TRUE,includeGates=TRUE,...){
	if(isNcdf&!@HAVE_NETCDF@){
	stop("isNcdf must be FALSE since you don't have netcdf installed");
	}
	message("We do not fully support all versions of flowJo XML workspaces at this time.")
	message("If your workspace is not supported or if this package throws an error, we encourage you to contact the package maintainter with a bug report. We will endeavour to add support for other features upon request.")
	##########################################################
	#path needs to be specified anyway to get full path of fcs
	#########################################################
#	if(execute){
    ##m<-match("path",names(list(...))) 
    path=list(...)$path     
    if(is.null(path)){ 
            ##stop("If execute=TRUE, you must specify a path to the fcs files via path= argument"); 
            path=obj@path 
    }
	#Check that the files exist now so we don't have to wait a long time.
	filenames<-flowWorkspace:::getFileNames(obj);
	#sapply(filenames,function(x)list.files(path=path,pattern=x,recursive=T))
	#	missingfiles<-!file.exists()
	#	if(length(which(missingfiles))/length(filenames)>=0.25){
	#		#warning(length(which(missingfiles))/length(filenames)*100,"% of the ",length(filenames)," FCS files can't be found at ",obj@path);
	#		#warning("They will be excluded from the import");
	#		#warning("Perhaps you want to specify a correct path to the files or copy the missing files over?")
	#	}
#	}
#	browser()
	x<-obj@doc;
	.hasNN(x);
	wsversion<-xpathApply(x,"/Workspace",function(z)xmlGetAttr(z,"version")[[1]])[[1]];
	if(wsversion=="1.6"){
		#Windows version code
		s<-.getSamples(x,win=TRUE);
		g<-.getSampleGroups(x,win=TRUE);
	}else{
		s<-.getSamples(x);
		g<-.getSampleGroups(x);
	}
	sg<-merge(s,g,by="sampleID");
	#requiregates - exclude samples where there are no gates? if(requiregates==TRUE)
	if(requiregates){
		sg<-sg[sg$pop.counts>0,]
	}
	if(wsversion=="2.0"){
		##samples may have no compID if they are only log-transformed, for example.
		##Keep samples with compID = NA and set it to -2
		#If the compID = NA, check the Sample Parameter attributes for the transformation information.
		message("Version recognised. Continuing..")
	}else if (wsversion=="1.6"){
		#Windows compensation and transformation work differently.. there is no comp id
		stop("Sorry, we don't support this type of workspace (flowJo Windows) at the moment. But we are working on it!")
		
	}else{
		stop("Workspace Version not supported");
	}
	sg$groupName<-factor(sg$groupName)
	groups<-levels(sg$groupName)
	if(is.null(name)){
	message("Choose which group of samples to import:\n");
	result<-menu(groups,graphics=FALSE);
	}else if(is.numeric(name)){
		if(length(groups)<name)
			stop("Invalid sample group index.")
		result<-name
	}else if(is.character(name)){
		if(is.na(match(name,groups)))
			stop("Invalid sample group name.")
		result<-match(name,groups)
	}
	if(wsversion=="2.0"){
		l<-sapply(sg[sg$groupName==groups[result],]$sampleID,function(i){
			xpathApply(x,paste("/Workspace/SampleList/Sample[@sampleID='",i,"']",sep=""))[[1]]
			})
	}else if(wsversion=="1.6"){
		l<-sapply(sg[sg$groupName==groups[result],]$sampleID,function(i){
			xpathApply(x,paste("/Workspace/SampleList/Sample/DataSet[@sampleID='",i,"']",sep=""))[[1]]
			})
	}else{
		stop("Workspace Version not Supported");
	}
#	browser()
	# Allow import of a subset of samples
	if(!missing(subset)){
		if(max(subset)<=length(l)&min(subset)>=1)
		l<-l[subset]
	}
	message("Parsing ",length(l)," samples");
	#TODO parallelize
	if(length(grep("snowfall",loadedNamespaces()))==1){
	    if(is.null(sfGetCluster())){
	        stop("Must initialize snowfall cluster first")
	    }
	    sfLibrary(flowWorkspace)
	    for(Z in 1:length(l)){
	        l[[Z]]<-xmlGetAttr(l[[Z]],"nn")
        }
	    #I believe this breaks because the underlying C xml object is not available on the other nodes, and I'm not sure how to export it.
	    #here's what we'll do.. send the "nn" id for the top level nodes in l.
	    #convert the document to a character representation and save/send it to the nodes (x)
	    #Each node parses the document and pulls up the necessary "nn" node, then continues. 
	    tmp<-saveXML(xmlRoot(x))
	    message("exporting XML tree to nodes")
	    tf<-tempfile()
	    save(tmp,file=tf);
	    sfExport("tf","TEMP")
	    rm(tmp);gc()
	    clusterEvalQ(sfGetCluster(),{load(tf);tmp<-xmlRoot(xmlTreeParse(tmp, asText = TRUE, useInternal = TRUE));invisible()})
	    message("parsing")
		G<-sfLapply(l,function(x){
		    #parse the exported variable
		    #x<-xmlRoot(xmlTreeParse(tmp, asText = TRUE, useInternal = TRUE))
		    x<-xpathApply(tmp,paste("//node()[@nn=",x,"]",sep="\'"))[[1]]
			message("Parsing sampleID ",xmlGetAttr(x,"sampleID"));
			.getPopulations(x,env=NULL,includegates=includeGates);
			graph<-get("gr",get("env",globalenv()))
			if(exists("transformations",env)){
				transformations<-get("transformations",get("env",globalenv()))
			}else{
				transformations<-list();
			}
			if(exists("compensation",env)){
				compensation<-get("compensation",get("env",globalenv()))
			}else{
				compensation<-matrix();
			}
			rm(x);gc()
			tf<-tempfile()
			ret<-list(graph=graph,transformations=transformations,compensation=compensation)
			if(!file.exists(TEMP)){
			    dir.create(TEMP,recursive=TRUE)
			}
			save(ret,file=file.path(TEMP,basename(tf)));
			return(file.path(TEMP,basename(tf)));
			})
			#run through G and reconstruct the object)
			for(i in seq_along(G)){
			    load(G[[i]]);
			    G[[i]]<-ret;
			    cat(".")
			}
			#seems to work.. passing the large data back and forth is not optimal.. could save to disk and have the master node read it from disk and construct the required object.
		#stop the snowfall cluster, we're done.
		sfStop();	
	}else if(length(grep("multicore",loadedNamespaces()))==1){
	    G<-multicore::mclapply(l,function(x){
	        message("Parsing sampleID ",xmlGetAttr(x,"sampleID"));
			.getPopulations(x,env=NULL,includegates=includeGates);
			graph<-get("gr",get("env",globalenv()))
			if(exists("transformations",env)){
				transformations<-get("transformations",get("env",globalenv()))
			}else{
				transformations<-list();
			}
			if(exists("compensation",env)){
				compensation<-get("compensation",get("env",globalenv()))
			}else{
				compensation<-matrix();
			}
			list(graph=graph,transformations=transformations,compensation=compensation)
	    })
	}else{
	G<-lapply(l,function(x){
		message("Parsing sampleID ",xmlGetAttr(x,"sampleID"));
		.getPopulations(x,env=NULL,includegates=includeGates);
		graph<-get("gr",get("env",globalenv()))
		if(exists("transformations",env)){
			transformations<-get("transformations",get("env",globalenv()))
		}else{
			transformations<-list();
		}
		if(exists("compensation",env)){
			compensation<-get("compensation",get("env",globalenv()))
		}else{
			compensation<-matrix();
		}
		list(graph=graph,transformations=transformations,compensation=compensation)
		})
	}
	
		fn<-do.call(c,lapply(G,function(x){		
			get("fcsfile",env=nodeDataDefaults(x$graph,"metadata"))
		}))
		names(G)<-fn
	
		excludefiles<-vector("numeric")
		for(i in 1:length(G)){
			nodeDataDefaults(G[[i]]$graph,"group")<-groups[result]
			#########################################################
			#get full path for each fcs and store in dataPath slot
			#########################################################
			file<-names(G[i])
			lastwarn<-options("warn")[[1]];
			options("warn"=-1);
			##escape "illegal" characters
			file<-gsub("\\)","\\\\)",gsub("\\(","\\\\(",file))
			absPath<-list.files(pattern=paste("^",file,"",sep=""),path=path,recursive=TRUE,full=TRUE)
			options("warn"=lastwarn)
			if(length(absPath)==0){
				warning("Can't find ",file," in directory: ",path,"\n");
				excludefiles<-c(excludefiles,i);
			}else{
				G[[i]]$dataPath<-dirname(absPath[1])
			}
		}
		#Remove samples where files don't exist.
		if(length(excludefiles)>0){
			message("Removing ",length(excludefiles)," samples from the analysis since we can't find their FCS files.");
			G<-G[-excludefiles];
		}
		
		G<-lapply(G,function(x)new("GatingHierarchy",tree=x$graph,nodes=nodes(x$graph),name=get("fcsfile",env=nodeDataDefaults(x$graph,"metadata")),flag=FALSE,transformations=x$transformations,compensation=x$compensation,dataPath=x$dataPath,isNcdf=isNcdf))
		G<-new("GatingSet",set=G);
		##################################################
		#create ncdf file without adding matrices yet
		#################################################	
		
		if(execute){
			#comments:maybe execute should not be exposed to 
			#users for gating separately from parseWorkspace because ncdfFlow object is created during
			#executing provess and stored in gatingHierarchy after transformation
			if(isNcdf){
				ncfs1  <-read.ncdfFlowSet(files=getSamples(G,isFullPath=TRUE),flowSetId="fs1",isWriteSlice=TRUE)				
				dataEnvironment=new.env(parent=.GlobalEnv);
				assign("ncfs",ncfs1,envir=dataEnvironment)
			}else{
			    dataEnvironment<-NULL
			    ncfs1<-NULL
			}
			if(.packageLoaded("Rmpi")){	
				#nslaves=4
				mpi.spawn.Rslaves(nslaves=nslaves)
				mpi.remote.exec(library(flowWorkspace))
				if(isNcdf){
				    mpi.remote.exec(library(ncdfFlow))
			    }
				mpi.bcast.Robj2slave(ws)
				mpi.bcast.Robj2slave(G)
				mpi.remote.exec(options("flowWorkspace_mpi_communication"=TRUE));
				mpi.remote.exec(options("flowWorkspace_mpi_read_token"=FALSE    ));
				options("flowWorkspace_mpi_communication"=FALSE)
				mpi.bcast.Robj2slave(ncfs1)
				mpi.bcast.Robj2slave(dataEnvironment)
				wrapper<-function(){
					more<-1;
					while(more==1){
						#ask for a task
						mpi.send.Robj(0,0,1)
						i<-mpi.recv.Robj(0,2)
						if(!is.na(i)){
						g<-execute(G[[i]],isNcdf=isNcdf(G[[i]]),ncfs=ncfs1,dataEnvironment=dataEnvironment)
						
						mpi.send.Robj(g,0,5)
    					rm(g);gc(reset=T);	

    					#are there more tasks?
    					mpi.recv.Robj(0,mpi.any.tag())
    					sourcetag<-mpi.get.sourcetag();
    					if(sourcetag[2]==7){
    						#Nope I'm done!
    						more<-0
    						next;
    					}
					}else{
					    more<-0;
					    next;
					}
						
					}
				}
				
				#in master
				mpi.bcast.Robj2slave(wrapper);
				mpi.bcast.cmd(wrapper())
				
				#divy up the tasks
				ntasks<-length(G);
				tasks<-1:ntasks
				state<-0;
				readlock<-0;
				readqueue<-NULL;
				writequeue<-NULL
				pending<-NULL
				results<-NULL;
				while(length(tasks)>0|length(results)<ntasks){
					#message("length(tasks): ", length(tasks), " length(results): ", length(results))
					#message("checking if anyone needs to write")
					if(readlock==0&state==0&length(writequeue)>0){
						#okay, go for it
						#message("they can write")
						mpi.send.Robj(0,writequeue[1],4)
						#message("okay, they're writing")
						writequeue<-writequeue[-1L]
						state<-1;
					}
					#give permission to the next thread to read
					if(state==0&readlock==0&length(readqueue)>0){
					    #11 permission to read
					    mpi.send.Robj(0,readqueue[1],11)
					    readqueue<-readqueue[-1L]
					    readlock<-1;
					}
					#listen for a request
					#message("listening")
					obj<-mpi.recv.Robj(mpi.any.source(),mpi.any.tag())
					sourcetag<-mpi.get.sourcetag();
					who<-sourcetag[1]
					what<-sourcetag[2]
					#Asking for data
					if(what==1){
						#message("they want data")
						if(length(tasks)>0){
						    mpi.send.Robj(tasks[1],sourcetag[1],2);
						    message("Gating");
    						tasks<-tasks[-1L]
					    }else{
					        mpi.send.Robj(NA,sourcetag[1],2);
					    }
						#message("sent them data")
					}
					#Needs permission to write to NetCDF
					if(what==3){
						#queue up
						#message("they want do write to ncdf")
						writequeue<-c(writequeue,who)
					}
					#They sent me a result
					if(what==5){
						#message("they have a result")
						results<-c(results,obj)
						#Do I have any more data to hand out?
						if(length(tasks)>0){
							#message("there's more results for ",who)
							mpi.send.Robj(0,who,6)
							#message("they got more results")
						}else{
							#message("there's no more results for ", who)
							mpi.send.Robj(0,who,7)
							#message("moving on")
						}
					}
					if(what==8){
						#message("they're done writing")
						state<-0
					}
					#read lock..
					#12 done reading
					if(what==12){
					    readlock<-0;
					}
					#10 permission to read
					if(what==10){
					    #Asking Permission to Read
					   readqueue<-c(readqueue,who);
					}
				}
				#Need to clear any remaining requests;
				
                #message("done gating; Merging results")
				#results is a list. Need to merge the ncdfFlowSet metadata.
				if(isNcdf){
				    ncfses<-lapply(results,function(x)nodeData(x@tree,getNodes(x)[1],"data")[[1]][["data"]]$ncfs)
				    names(ncfses)<-unlist(lapply(results,function(x)x@name),use.names=FALSE)
				    snames<-names(ncfses)
				    message("Cloning flowset")
				    newnc<-ncdfFlow::clone.ncdfFlowSet(ncfses[[1]],isNew=FALSE,isEmpty=FALSE)
				    for(samp in snames){
        				newnc@frames[[samp]]<-ncfses[[samp]]@frames[[samp]]
        			}
        			colnames(newnc)<-colnames(as.list(newnc@frames)[[1]])
        			denv<-nodeData(results[[1]]@tree,getNodes(results[[1]])[[1]],"data")[[1]][["data"]]
        			assign("ncfs",newnc,denv)
        			for(i in 1:length(results)){
        				assign("data",denv,nodeData(results[[i]]@tree,getNodes(results[[i]])[1],"data")[[1]])
        			}            
			    }else{
			        
			    }
				G<-new("GatingSet",set=results)
				rm(results);
				gc(reset=TRUE);
				mpi.remote.exec(options("flowWorkspace_mpi_communication"=FALSE));
				options("flowWorkspace_mpi_communication"=NULL)
			}
			else{
				G<-lapply(G,function(x)execute(hierarchy=x,isNcdf=isNcdf(x),ncfs=ncfs1,dataEnvironment=dataEnvironment))
			}
		}
		return(G);
})

#From https://stat.ethz.ch/pipermail/r-help/2005-September/078974.html
#Detects Rmpi support since Rmpi doesn't have a namespace, and we don't want to "require" it
.packageLoaded <- function(name)
{
    ## Purpose: is package 'name' loaded?
    ## --------------------------------------------------
    (paste("package:", name, sep="") %in% search()) ||
    (name %in% loadedNamespaces())
}    

.parseBooleanGate<-function(x,y,z){
	x<-gsub("! G","!G",x)
	
	tokens<-strsplit(x," ")[[1]]
	##Pull off each token. 
	#eliminate space between ! G..
	N<-(length(tokens)+1)/2
	#N<-length(grep("G",tokens)) #Number of gates;
	gind<-(1:N)*2-1	
	#gind<-grep("G",tokens); #gate indices
	if(N>1){
		lind<-(1:(N-1))*2
	}else{
		lind<-0;
	}
	reord<-order(as.numeric(gsub("!","",gsub("G","",tokens[gind]))))
	refs<-sapply(y,function(nme){
		##conditionally generate a query based on the full population name
		if(length(strsplit(nme,"/")[[1]])==2&strsplit(nme,"/")[[1]][1]==""){
			#Code for relative pop name
			##TODO bug here when the parent is the root
			nd<-xpathApply(z,paste("./ancestor::Population[2]/descendant::Population[@name='",basename(nme),"']",sep=""))			
			if(is.null(nd)){
			    nd<-xpathApply(z,paste("./ancestor::SampleNode[1]/descendant::Population[@name='",basename(nme),"']",sep=""))
			}
			nd<-nd[[1]]
			paste(xmlGetAttr(nd,"nn"),xmlGetAttr(nd,"name"),sep=".");
		}else{
			prefix<-"./ancestor::Sample/";
			query<-paste(prefix,sapply(strsplit(nme,"/")[[1]][!strsplit(nme,"/")[[1]]==""],function(q){
				paste("descendant::Population[@name='",q,"']",sep="")
				}),collapse="/")
			nd<-xpathApply(z,query)[[1]]
			paste(xmlGetAttr(nd,"nn"),xmlGetAttr(nd,"name"),sep=".")
		}
	})[reord]
	not<-grep("!",tokens[gind])
	and<-grep("\\&",tokens[lind])
	or<-grep("\\|",tokens[lind])
	e<-grep("!",tokens[gind],invert=TRUE)
 	v<-vector(mode="character",length=length(gind))
	v2<-vector(mode="character",length=length(lind));
	v[not]<-"!"
	v[e]<-""
	v2[and]<-"&"
	v2[or]<-"|"
	g<-list(v=v,v2=v2,ref=refs);
	class(g)<-"BooleanGate";
	return(g)
}
.parseBooleanGates<-function(x,g){
	
	x<-xpathApply(x,"./BooleanGate")[[1]];
	#x is a single gate now.
	def<-xmlGetAttr(x,"specification")
	## generate a query based on the full population name
	gnames<-unlist(xpathApply(x,".//String",function(x)(xmlValue(x))),use.names=FALSE)
	nm<-xpathApply(x,"./parent::Population",function(x){nm<-xmlGetAttr(x,"name");nn<-xmlGetAttr(x,"nn");paste(nn,nm,sep=".");})[[1]]
	pname<-xpathApply(x,"./parent::Population/parent::node()",xmlName)
	if(pname=="SampleNode"){
	    attachto<-sapply(1,function(i){p<-xpathApply(x,"./parent::Population/parent::SampleNode",xmlAttrs)[[1]];p["name"]})
	}else{
	    attachto<-sapply(1,function(i){p<-xpathApply(x,"./parent::Population/parent::Population",xmlAttrs)[[1]];paste(p["nn"],".",p["name"],sep="")})
	}
	
	
	
	
	counts<-sapply(1,function(i){xpathApply(x,"./parent::Population",function(x)xmlGetAttr(x,"count"))[[1]]})
	fjname<-sapply(1,function(i){paste(unlist(xpathApply(x,"./ancestor::Population",function(x)xmlGetAttr(x,"name")),use.names=FALSE),collapse="/")});
	#message("Boolean Gate",nm,"\n")
	g<-graph::addNode(nm,g)
	g<-graph::addEdge(attachto,nm,g)
	nodeData(g,nm,"metadata")<-new.env(parent=emptyenv());
	assign("isBooleanGate",TRUE,env=nodeData(g,nm,"metadata")[[1]])
	struct<-list(.parseBooleanGate(def,gnames,x))
	attr(struct,"type")<-"BooleanGate";
	assign("gate",struct,env=nodeData(g,nm,"metadata")[[1]])
	assign("count",counts,env=nodeData(g,nm,"metadata")[[1]]);
	assign("fjName",fjname,env=nodeData(g,nm,"metadata")[[1]]);
	#20110314
	assign("isGated",FALSE,env=nodeData(g,nm,"metadata")[[1]])
	
	#Don't have these yet.. get them later.
	#assign("parentTot",NA,env=nodeData(g,nm,"metadata")[[1]])
	#assign("thisTot",NA,env=nodeData(g,nm,"metadata")[[1]])
	#assign("thisIndices",list(),env=nodeData(g,nm,"metadata")[[1]])
	return(g);
}
setMethod("[",signature("GatingSet"),function(x,i,j,...,drop){
	x@set<-x@set[i]
	x@metadata<-x@metadata[i]
	return(x);
})

#TODO test if the clone is update properly in all its environments
#TODO major bug here. cloning is not wokring properly
cloneGatingSet<-function(x,clone.data=FALSE,clone.gating=FALSE){
	clone<-x
	gdata<-new.env();
	#copy the global data environment
	copyEnv(x[[1]]@tree@nodeData@defaults$data[["data"]],gdata)
	for(i in 1:length(x)){
		nd<-x[[i]]@tree@nodeData
		nd@defaults$metadata<-new.env()
		nd@defaults$data<-new.env()
		copyEnv(x[[i]]@tree@nodeData@defaults$data,nd@defaults$data)
		nd@defaults$data[["data"]]<-gdata
		copyEnv(x[[i]]@tree@nodeData@defaults$metadata,nd@defaults$metadata)
		nlist<-replicate(length(nd@data),list(list(metadata=new.env())))
		for(j in 1:length(nlist)){
			copyEnv(nd@data[[j]]$metadata,nlist[[j]]$metadata)
		}
		names(nlist)<-names(nd@data)
		nd@data<-nlist
		clone[[i]]@tree@nodeData<-nd
	}
	
	if(clone.data&isNcdf(x[[1]])){
		nc<-getNcdf(clone)
		clone.nc<-ncdfFlow::clone.ncdfFlowSet(nc,isEmpty=FALSE,isNew=TRUE)
		for(i in 1:length(clone)){
			assign("ncfs",clone.nc,nodeData(clone[[i]]@tree,getNodes(clone[[i]])[1],"data")[[1]][["data"]])
		}
	}else{
		warning("Can't clone ncdf data. This GatingSet doesn't use netcdf")
	}
	if(clone.gating&isNcdf(x[[1]])){
		writeGatingSetGatesToNetCDFParallel(clone,isNew=TRUE)
	}else{
		warning("Can't clone ncdf gating. This GatingSet doesn't use netcdf")
	}
	clone
}

setMethod("[[",signature("GatingSet"),function(x,i,j,...){
	return(x@set[[i]]);
})
setReplaceMethod("[[",signature("GatingSet",value="GatingHierarchy"),function(x,i,j,...,value){
	if(length(i)!=1){
		stop("subscript out of bounds (index must have length 1)");
	}
	x@set[[i]]<-value
	return(x)
})
## Test this method.. not sure if it works correctly.
setReplaceMethod("[",signature("GatingSet",value="GatingSet"),function(x,i,j,...,value){
	x@set[i]<-value@set
	pData(x)[i,]<-pData(value)[i,]
	return(x);
})
setMethod("length","GatingSet",function(x){
	length(x@set);
})
setMethod("lapply","GatingSet",function(X,FUN,...){
	##return a GatingSet unless the function FUN is not suitable, in which case return the list.
	r<-lapply(X@set,FUN,...)
	result<-try(new("GatingSet",set=r),silent=TRUE);
	if(inherits(result,"try-error")){
		result<-r;
	}else{
		result@metadata<-X@metadata;
	}
	result;
})

setMethod("show","GatingSet",function(object){
	cat("A GatingSet with ",length(object), " samples\n")
	for(i in 1:length(object)){
		cat(i,". ");
		show(object[[i]])
	}
})

setMethod("pData","GatingSet",function(object){
	pData(object@metadata)
})
setReplaceMethod("pData",c("GatingSet","data.frame"),function(object,value){
	pData(object@metadata)<-value;
	return(object);
})

setMethod("show","GatingHierarchy",function(object){
	cat("\tFCS File: ",object@name,"\n");
	cat("\tGatingHierarchy with ",length(object@nodes)," gates\n");
})
setMethod("getNodes","GatingHierarchy",function(x,tsort=FALSE,...){
	if(!tsort){
		return(x@nodes)
	}else{
		return(RBGL::tsort(x@tree))
	}
})

getFileNames<-function(ws){
	if(class(ws)!="flowJoWorkspace"){
		stop("ws should be a flowJoWorkspace")
	}else{
		unlist(xpathApply(ws@doc,"/Workspace/SampleList/Sample/Keywords/Keyword[@name='$FIL']",function(x)xmlGetAttr(x,"value")),use.names=FALSE);
	}
}

setMethod("execute",signature(hierarchy="GatingHierarchy"),function(hierarchy,cleanup=FALSE,keep.indices=TRUE,isNcdf=FALSE,ncfs=NULL,dataEnvironment=NULL,...){
		##Conditional compilation for HAVE_NETCDF
		if(isNcdf&!@HAVE_NETCDF@){
		stop("isNcdf must be FALSE, since you don't have netcdf installed");
		}
		if(hierarchy@flag){
			message("This file is already gated\n")
			return()
		}
		
		x<-hierarchy@tree;
		
		#doc<-workspace@doc
		nlist<-RBGL::bfs(x,nodes(x)[1]);
		file<-getSample(hierarchy,isFullPath=TRUE)

		message("Loading data file: ",file);
		data<-read.FCS(file);

		cid<-get("compID",env=nodeData(x,nlist[1],"metadata")[[1]])
		cal<-hierarchy@transformations;

		if(cid!=-1 & cid!=-2){
			message("Compensating");
			#compobj<-compensation(.getCompensationMatrices(doc)[[as.numeric(cid)]])
			compobj<-compensation(hierarchy@compensation);
			#TODO this compensation will fail if the parameters have <> braces (meaning the data is stored compensated).
			#I need to handle this case properly.
			res<-try(compensate(data,compobj),silent=TRUE)
			if(inherits(res,"try-error")){
				message("Data is probably stored already compensated");
			}else{
				data<-res
				rm(res);
				gc(reset=TRUE);
			}
			cnd<-colnames(data)
			if(is.null(cnd)){cnd<-as.vector(parameters(data)@data$name)}
			wh<-cnd%in%parameters(compobj)
			cnd[wh]<-paste("<",parameters(compobj),">",sep="")
			
			#colnames(data)<-cnd;
			e<-exprs(data)
			d<-description(data);
			p<-parameters(data);
			p@data$name<-cnd
			colnames(e)<-cnd;
			data<-new("flowFrame",exprs=e,description=d,parameters=p)						
			#cmnm<-names(.getCompensationMatrices(doc))[as.numeric(cid)]
			#Don't need this anymore.
			# #cal<-.getCalibrationTableSearch(doc,cmnm)
			# if(length(cal)==0){
			# 	stop("Can't find the calibration table named : ", cmnm, " in this workspace.");
			# }
		}
		else if(cid==-2){
			#TODO the matrix may be acquisition defined.
			message("No compensation");
		}
		else if(cid==-1){
			##Acquisition defined compensation.
			#nm<-unique(do.call(c,lapply(strsplit(.getCalibrationTableNames(doc)," "),function(x)x[1])))[2]
			nm<-hierarchy@compensation;
			if(grepl("Acquisition-defined",nm)){
				###Code to compensate the sample using the acquisition defined compensation matrices.
				message("Compensating with Acquisition defined compensation matrix");
				#browser()
				comp<-compensation(spillover(data)$SPILL)
				hierarchy@compensation<-spillover(data)$SPILL
				res<-try(compensate(data,comp),silent=TRUE)
				if(inherits(res,"try-error")){
					message("Data is probably stored already compensated");
				}else{
					data<-res
					rm(res);
					gc(reset=TRUE);
				}
				cnd<-colnames(data)
				wh<-cnd%in%parameters(comp)
				cnd[wh]<-paste("<",parameters(comp),">",sep="")
				e<-exprs(data)
				d<-description(data);
				p<-parameters(data);
				p@data$name<-cnd
				colnames(e)<-cnd;
				data<-new("flowFrame",exprs=e,description=d,parameters=p)
				gc(reset=TRUE);
			}
			#Ditto
			#cal<-.getCalibrationTableSearch(doc,nm)
		}
		gc(reset=TRUE)
		message("Transforming");
		axis.labels<-list();
		.flowJoTransform(environment(),cal);
		gc(reset=TRUE);
		#wh<-which(data@parameters@data$name=="Time")
		wh<-grep("^Time$",data@parameters@data$name)
		if(length(wh!=0)){
		gc(reset=TRUE);
		parameters(data)@data[wh,4:5]<-range(exprs(data[,wh]));
		gc(reset=TRUE);
		parameters(data)@data[wh,3]<-diff(range(exprs(data[,wh])));
		}
		gc(reset=TRUE);
		# if(!isNcdf){
			e<-new.env(parent=.GlobalEnv);
		# }
		#########################################
		#if use ncdfFlowSet,then add the transformed
		#matrix to the ncdf file,assign it to env
		#########################################
		if(!isNcdf)
			assign("data",data,envir=e)
		else
		{
			sampleName<-getSample(hierarchy)

			#create ncdf file for indices
			#moving this code to writeGatesToNetCDF
			
			if(.packageLoaded("Rmpi")){
				#ask for permission to write to netcdf
				mpi.send.Robj(0,0,3)
				mpi.recv.Robj(0,4)
				addFrame(dataEnvironment$ncfs,data,sampleName)
		
				
				#let master know I'm done
				mpi.send.Robj(0,0,8)

			}else{
				addFrame(dataEnvironment$ncfs,data,sampleName)
			}

			###all the annotData including colnames for each flowFrame slots are already updated in addFrame funciton
			###but not the colnames slot in ncdfFlow,this redundant slot seems cause problem,consider to be removed
			colnames(dataEnvironment$ncfs)<-colnames(data)##currently it is updated repeatedly by each sample
			colnames(ncfs)<-colnames(data)
			multiassign(c("data","sampleName"),list(dataEnvironment,sampleName),envir=e)
		}
		assign("axis.labels",axis.labels,envir=e);
		rm(data);
		gc(reset=TRUE)
		nodeDataDefaults(x,"data")<-e;
		#Nodes to parse later
		skipforlater<-list();
		lastparent<-nlist[1];
		for (node in nlist){
			#20110314 check if the current node has already been gated
			if(.isGated.graphNEL(hierarchy,node))
				next
			else
			{
				parentname<-(setdiff(adj(ugraph(x),node)[[1]],adj(x,node)[[1]]));
				if(length(parentname)==0){
					parentname<-node
					
					assign("thisTot",as.numeric(nodeData(x,node,"metadata")[[1]][["count"]]),env=nodeData(x,node,"metadata")[[1]]);
					hierarchy@tree<-x;
					##the bug discovered and fixed on 06132011
#					assign("thisIndices",list(getIndices(hierarchy,node),env=nodeData(x,node,"metadata")[[1]]));
					l<-list(getIndices(hierarchy,node))
#					browser()
					.saveIndices(x,sampleName,node,l,isNcdf=FALSE)
					
					#20110314 set the flag after gating
					assign("isGated",TRUE,env=nodeData(x,node,"metadata")[[1]])
					lastparent<-parentname;
					next;
				};
				if(lastparent!=parentname&length(skipforlater)!=0){
					hierarchy@tree<-x;
					for(i in skipforlater){
#						browser()
						
						hierarchy<-.calcBooleanGate(hierarchy,i)
					}
					skipforlater<-list();
					lastparent<-parentname;
				}
				hierarchy@tree<-x;
				if(.isBooleanGate.graphNEL(hierarchy,node)){
					#Skip Boolean Gates and Compute them later
					skipforlater<-c(skipforlater,node);
					lastparent<-parentname;
					next;
				}
				#check if the current node has been gated during the skipforlater loop
				#Perhaps this check should go into .calcGate?
				#Done - check is inside .calcGate
				#gating the regular gate

				.calcGate(hierarchy,node)
				#}
				lastparent<-parentname;
			}
		}
		if(length(skipforlater)!=0){
			hierarchy@tree<-x;
			for(i in skipforlater){
				hierarchy<-.calcBooleanGate(hierarchy,i)
			}
			skipforlater<-list();
		}
		
		#Done gating, now write all the indices to netcdf
		#Checks the ncdf flag of hierarchy in the function
#		browser()
		hierarchy@flag<-TRUE;
		writeGatesToNetCDF(hierarchy,isNew=TRUE)
		
		if(cleanup){
			nodeDataDefaults(x,"data")<-new.env(parent=.GlobalEnv);
			gc(reset=TRUE);
		}
		hierarchy@tree<-x;
		# message("Computing Boolean Gates");
		# hierarchy<-.calcBooleanGates(hierarchy);
		
		hierarchy
})


##make a copy of ncfs and indice files from the gating hierarchy,by default they are saved in tmp folder which is not persistent storage
saveNcdf<-function(objName,path=getwd()){
			if(!file.exists(path))
			{
				dir.create(path)
			}
			
#			browser()
			obj<-get(objName,parent.frame(2))
#			eval(parse(text=paste("get('",objName,"',parent.frame(2))",sep="")))
			
			##copy cdf file for ncdfFlowSet 
			ncfsFile.src<-getNcdf(obj)@file
			ncfsFile.dest<-file.path(path,basename(ncfsFile.src))
			if(ncfsFile.src!=ncfsFile.dest){
				file.copy(from=ncfsFile.src,to=ncfsFile.dest)
				file.remove(ncfsFile.src)
			}
			#update ncdfFlowSet object in gating set
			#need to update all the gating hierarchy data environments, not just the first..
			for(i in 1:length(obj))
			{
				nodeData(obj[[i]]@tree,getNodes(obj[[i]],tsort=FALSE)[1],"data")[[1]][["data"]]$ncfs@file<-ncfsFile.dest
			}
							
			
			##copy cdf files for indices 
			for(i in 1:length(obj))
			{
				hierarchy<-obj[[i]]
				ncIndiceFile.src<-getIndiceFile(hierarchy)
				ncIndiceFile.dest<-file.path(path,basename(ncIndiceFile.src))
				if(ncIndiceFile.src!=ncIndiceFile.dest){
					file.copy(from=ncIndiceFile.src,to=ncIndiceFile.dest)
					file.remove(ncIndiceFile.src)
				}
				#update indice filename in hierarchy
				nodeData(obj[[i]]@tree,getNodes(obj[[i]],tsort=FALSE)[1],"data")[[1]]$IndiceFile<-ncIndiceFile.dest
				
			}
						
		
		}

#Checks the ncdf flag of hierarchy in the function
#Writes the gates to netcdf. 
#We can optionally move a gatinghierarchy from memory to netcdf this way.
writeGatingSetGatesToNetCDFParallel<-function(gatingset,isNew=FALSE){
	if(!is.na(match("multicore",loadedNamespaces()))&!is.na(match("foreach",loadedNamespaces()))&!is.na(match("doMC",loadedNamespaces()))){
		#Don't need to return anything after the parallel call since the goal is just to write to the netcdf files.
		tmp<-unlist(multicore::mclapply(gatingset@set,function(y){flowWorkspace:::writeGatesToNetCDF(y,isNew=isNew);getIndiceFile(y)}),use.names=FALSE)
		#here I may need to set the thisIndices to NA.
		for(i in 1:length(tmp)){
			#Update the indices file
			if(isNew){
				assign("IndiceFile",tmp[i],env=nodeData(gatingset[[i]]@tree,getNodes(gatingset[[i]])[1],"data")[[1]])
			}
			#Tell each node in the tree that we are now using ncdf-based gate indices
			for(node in getNodes(gatingset[[i]])){
				assign("thisIndices",NULL,env=nodeData(gatingset[[i]]@tree,node,"metadata")[[1]])
			}
		}
	}else{
		for(j in 1:length(gatingset)){
				flowWorkspace:::writeGatesToNetCDF(gatingset[[j]],isNew=isNew)
		}
	}
}
writeGatesToNetCDF<-function(hierarchy,isNew=FALSE){
#	browser()
#	save(hierarchy,file="hierarchy.rda")
#	load("hierarchy.rda")
	if(isNcdf(hierarchy)){
#		nlist<-RBGL::bfs(hierarchy@tree)
		nlist<-getNodes(hierarchy)
		#Filter boolean gates
		nlist<-nlist[sapply(nlist,function(x)!flowWorkspace:::.isBooleanGate.graphNEL(hierarchy,x))]
		len<-length(getIndices(hierarchy,nlist[1]))
		
		##get all indices in the format of raw bit vector
		indiceMat<-lapply(nlist,function(curNode,obj=hierarchy){
						
						curIndice<-getIndices(obj,curNode)
						.makeBitVec(length(curIndice),curIndice)
						})
		
		#use the existing file when indice file already exists and isNEW==FALSE 
		IndiceFile<-getIndiceFile(hierarchy)
		if(is.null(IndiceFile)||isNew)##other wise generate a new file name
		{
			sampleName<-getSample(hierarchy)
			IndiceFile<-tempfile(pattern = paste(sampleName,Sys.getpid(),sep="."),tmpdir=dirname(getNcdf(hierarchy)@file))
			if (!length(grep(".", IndiceFile, fixed = TRUE)))  
				IndiceFile <- paste(IndiceFile, "nc", sep = ".")		
			#create the new file
			ncdfFlow:::createIndiceFile(IndiceFile,eventCount=len,nlist)
			
		}else if(!file.exists(IndiceFile)){
			ncdfFlow:::createIndiceFile(IndiceFile,eventCount=len,nlist)
		}
		#save filename to data environment
		assign("IndiceFile",IndiceFile,nodeData(hierarchy@tree,getNodes(hierarchy,tsort=FALSE)[1],"data")[[1]])
				
		##try to save atrritubes before merge the list into matrix
		bitlen<-NULL
		nbitset<-NULL
		bitlen<-unlist(lapply(indiceMat,attr,"bitlen"),use.names=FALSE)	
		nbitset<-unlist(lapply(indiceMat,attr,"nbitset"),use.names=FALSE)
		##merge to matrix and add the attributes from each individual indice vector
		indiceMat<-do.call("cbind",indiceMat)		
		attr(indiceMat,"bitlen")<-bitlen[1]#assume all the vector has same length,so only save the first one
		attr(indiceMat,"nbitset")<-nbitset
		#now write all the indices as one block
		#we'll remove the old file and recreate it.. this is a workaround for problems arising when a new gate is added somewhere and the block being written changes size.
			file.remove(IndiceFile)
			ncdfFlow:::createIndiceFile(IndiceFile,eventCount=len,nlist)
			result<-try(ncdfFlow:::writeIndice(list(ncFile=IndiceFile,nlist=nlist),indiceMat,startNode=nlist[[1]]))
		
		#And set the indices in memory to NULL
		for(node in nlist){
			assign("thisIndices",NULL,env=nodeData(hierarchy@tree,node,"metadata")[[1]])
		}
	}
}

#20110314
#TODO wrap isNcdf slot with get/set methods
isNcdf<-function(x){
	if(inherits(x,"GatingHierarchy"))
	return(x@isNcdf)
}
setNcdf<-function(x,y){
	if(inherits(x,"GatingHierarchy")&class(y)=="logical"){
		x@isNcdf=y
	}
	return(x);
}
#isNcdf should be FALSE for .calcGate, until we get the full sample completed.
.calcGate<-function(hierarchy,node,force=FALSE){
	if(force){
		assign("isGated",FALSE,nodeData(hierarchy@tree,node,"metadata")[[1]])
	}
	if(!.isGated.graphNEL(hierarchy,node)){
		
	isNcdf<-isNcdf(hierarchy)
	sampleName<-getSample(hierarchy)
	parentname<-getParent(hierarchy,node)
	x<-hierarchy@tree
#	message("Gating ", node);
	g<-get("gate",env=nodeData(x,node,"metadata")[[1]]);
	#			browser()
	if(exists("negated",env=nodeData(x,node,"metadata")[[1]])){
		if(get("negated",env=nodeData(x,node,"metadata")[[1]])){
			hierarchy@tree<-x;
			
			
			l<-list(getIndices(hierarchy,parentname)&(!filter(getData(x),get("gate",nodeData(x,node,"metadata")[[1]]))@subSet))
			.saveIndices(x,sampleName,node,l,isNcdf=FALSE)	
		}else{
			hierarchy@tree<-x;
			l<-list(getIndices(hierarchy,parentname)&(filter(getData(x),get("gate",env=nodeData(x,node,"metadata")[[1]]))@subSet))
			.saveIndices(x,sampleName,node,l,isNcdf=FALSE)
		}
	}else{
		hierarchy@tree<-x;
		l<-list(getIndices(hierarchy,parentname)&(filter(getData(x),get("gate",env=nodeData(x,node,"metadata")[[1]]))@subSet))
		.saveIndices(x,sampleName,node,l,isNcdf=FALSE)
	}
	#TODO: get call getIndices method instead of directly access it,but the call to getIndices somehow cause
	#recursive loop,which has to do with the inter-call between .calGate and getIndices. Need to break this inter-call
	#on either routine in order to avoid the unexpected logical error--20110713 
	thisIndices<-get("thisIndices",env=nodeData(x,node,"metadata")[[1]])[[1]]
	if(class(thisIndices)=="raw")
		thisIndices<-.getBitStatus(thisIndices)
	l<-sum(thisIndices)
	l2<-get("thisTot",env=nodeData(x,parentname,"metadata")[[1]])
	multiassign(c("thisTot","isGated","parentTot"),list(l,TRUE,l2),env=nodeData(x,node,"metadata")[[1]])	
}
}
.saveIndices<-function(x,sampleName,node,l,isNcdf){
	if(isNcdf)##save indices in file
	{
		assign("thisIndices",NULL,env=nodeData(x,node,"metadata")[[1]])
	}else
	{
		l<-l[[1]]
		assign("thisIndices",list(.makeBitVec(length(l),l)),env=nodeData(x,node,"metadata")[[1]])
		
	}
	
}
.calcBooleanGate<-function(x,y){
#	message("Gating BooleanGate ",y, "\n");
	z<-sum(getIndices(x,y))
	z2<-sum(getIndices(x,getParent(x,y)))
	multiassign(c("thisTot","parentTot","isGated"),list(z,z2,TRUE),env=nodeData(x@tree,y,"metadata")[[1]])
	return(x);
}

setMethod("plot",signature("GatingHierarchy","missing"),function(x,y,layout="dot",width=3,height=2,fontsize=14,labelfontsize=14,fixedsize=FALSE,boolean=FALSE,...){
	if(!boolean){	
			sub<-subGraph(x@nodes[which(!unlist(lapply(nodeData(x@tree,x@nodes,"metadata"),function(x)get("isBooleanGate",env=x)),use.names=FALSE))],x@tree)
	}else{
		sub<-x@tree
	}
		nn<-sapply(nodes(sub),function(x)strsplit(x,"\\.")[[1]][2])
		nn[1]<-nodes(sub)[1]
		natr<-list();
		natr$label<-nn;
		options("warn"=-1)
		lay<-Rgraphviz::layoutGraph(sub,layoutType=layout,nodeAttrs=natr,attrs=list(graph=list(rankdir="LR",page=c(8.5,11)),node=list(fixedsize=FALSE,fontsize=fontsize,shape="rectangle")))
		renderGraph(lay)
		#plot(sub,nodeAttrs=natr,attrs=list(node=list(fixedsize=fixedsize,labelfontsize=labelfontsize,fontsize=fontsize,width=width,height=height,shape="rectangle")),y=layout,...);
		options("warn"=0)
})

setMethod("plotGate",signature(x="GatingHierarchy",y="numeric"),function(x,y,add=FALSE,border="red",tsort=FALSE,smooth=FALSE,fast=FALSE,...){
	node<-getNodes(x,tsort=tsort)[y];
	if(is.na(node)){
		warning("Can't plot gate ", y, " doesn't exist.");
		return(1);
	}
	plotGate(x,y=node,add=add,border=border,tsort=tsort,fast=fast,...);
})

setMethod("plotGate",signature(x="GatingHierarchy",y="character"),function(x,y,add=FALSE,border="red",tsort=FALSE,smooth=FALSE,fast=FALSE,...){
		if(!x@flag){
				message("Can't plot until you gate the data with 'execute()'\n");
			return();
		}
		#do we pass a "main" argument for the title?
		if(is.null(match.call()$main)){
		    #fjName
		    fjName<-mget(c("fjName"),nodeData(x@tree,y,"metadata")[[1]])
		    #sampleName
		    sname<-x@name
		    #construct plot title for this gate
            mtitle<-paste(sname,fjName,sep="\n")
            cl<-match.call(expand.dots=TRUE)
            cl$main<-mtitle
            return(eval(cl,parent.frame()));
        }
        cachedata<-getData(x,y);
		parentdata<-getData(x,getParent(x,y));
		rootdata<-getData(x);
		
        main<-match.call()$main;
		cols <- colorRampPalette(IDPcolorRamp(21,
		                               t(col2hsv(c("blue","green","yellow","red"))),
		                               fr=c(0.7,0.1)))
		
		##Two cases: gate is boolean, or gate is normal
		##Boolean gates are treated differently
		if(.isBooleanGate.graphNEL(x,y)){
			p<-getParent(x,y);
			ind<-getIndices(x,y)
			ind.p<-getIndices(x,p)
			pd<-parentdata
			dims<-getDimensions(x,p);
			if(!.isCompensated(x)){
			    pnames.data<-cachedata@parameters@data$name
			    pnames.desc<-cachedata@parameters@data$desc
			    pnames<-gsub(">","",gsub("<","",pnames.data))
			}else{
			    pnames<-pnames.data<-cachedata@parameters@data$name
    			pnames.desc<-cachedata@parameters@data$desc
			}
			dims<-pnames.data[match(dims,pnames)][na.omit(match(pnames,dims))]
			desc<-pnames.desc[match(dims,pnames)][na.omit(match(pnames,dims))]
			
			dim.ind<-getDimensions(x,p,index=TRUE)[na.omit(match(pnames,dims))]
			#dims<-dims[na.omit(match(pnames,dims))]
			if(add){
				points(exprs(pd[,dims]),col=as.numeric(ind[ind.p])+1,pch='.',xlab=paste(trimWhiteSpace(na.omit(dims[1])),desc[1],sep=" "),ylab=paste(trimWhiteSpace(na.omit(dims[2])),desc[2],sep=" "));
			}else{
			    if(!fast){
				    plot((pd[,dims]),xlab=paste(trimWhiteSpace(na.omit(dims[1])),desc[1],sep=" "),ylab=paste(trimWhiteSpace(na.omit(dims[2])),desc[2],sep=" "),col=as.numeric(ind[ind.p])+1,smooth=smooth,main=main);
			    }else{
			        plot(hexbin(pd[,dims]),xlab=paste(trimWhiteSpace(na.omit(dims[1])),desc[1],sep=" "),ylab=paste(trimWhiteSpace(na.omit(dims[2])),desc[2],sep=" "),col=as.numeric(ind[ind.p])+1)
			    }
				points(exprs(pd[,dims][ind[ind.p],]),col="red",cex=2,pch='.');
				
			}
			invisible()
		}else if(suppressWarnings(is.na(getGate(x,y)))){
			message("Can't plot. There is no gate defined for node ",y);
			invisible();			
		}else{
			if(add==FALSE){
			dims<-getDimensions(x,y)
			if(!.isCompensated(x)){
			    pnames.data<-(getData(x,y,tsort=tsort)@parameters@data$name)
    			pnames<-gsub(">","",gsub("<","",pnames.data))
			}else{
			    pnames<-pnames.data<-(getData(x,y,tsort=tsort)@parameters@data$name)
    			
			}
			dims2<-pnames.data[match(dims,pnames)][na.omit(match(pnames,dims))]
			#dims2<-dims[na.omit(match(pnames,dims))]
			dim.ind<-getDimensions(x,y,index=TRUE)[na.omit(match(pnames,dims))]
			par.desc<-parameters(parentdata)@data$desc[dim.ind]
			if(!any(is.na(par.desc))){
				dflag<-TRUE
			}else{
				dflag<-FALSE
			}
			pd<-parentdata[,dims2];
			if(dflag){
				#warning this may sometimes fail	
				colnames(pd)<-parameters(pd)@data$desc
			}
			#use dimnames from the data
			form<-mkformula(rev(dims2));
			if(length(dims2)==2){
			if(is.null(getAxisLabels(x)[[dim.ind[1]]])&is.null(getAxisLabels(x)[[dim.ind[2]]])){
				scales<-list()
				xlim=range(parentdata[,dims2[1]])
				ylim=range(parentdata[,dims2[2]])
			}else if(!is.null(getAxisLabels(x)[[dim.ind[1]]])&is.null(getAxisLabels(x)[[dim.ind[2]]])){
				scales<-list(x=list(at=getAxisLabels(x)[[dim.ind[1]]]$at,labels=getAxisLabels(x)[[dim.ind[1]]]$label),x=list(rot=45))
				xlim=range(getAxisLabels(x)[[dim.ind[1]]]$at)
				ylim=range(parentdata[,dims2[2]])
			}else if(is.null(getAxisLabels(x)[[dim.ind[1]]])&!is.null(getAxisLabels(x)[[dim.ind[2]]])){
				scales<-list(y=list(at=getAxisLabels(x)[[dim.ind[2]]]$at,labels=getAxisLabels(x)[[dim.ind[2]]]$label),x=list(rot=45))
				xlim=range(parentdata[,dims2[1]])
				ylim=range(getAxisLabels(x)[[dim.ind[2]]]$at)		
			}else if(!is.null(getAxisLabels(x)[[dim.ind[1]]])&!is.null(getAxisLabels(x)[[dim.ind[2]]])){
				scales<-list(x=list(rot=45,at=getAxisLabels(x)[[dim.ind[1]]]$at,labels=getAxisLabels(x)[[dim.ind[1]]]$label),y=list(at=getAxisLabels(x)[[dim.ind[2]]]$at,labels=getAxisLabels(x)[[dim.ind[2]]]$label))
				xlim=range(getAxisLabels(x)[[dim.ind[1]]]$at)
				ylim=range(getAxisLabels(x)[[dim.ind[2]]]$at)		
			}
			#If 2D use xyplot.
			#TODO add stains to labels
			xylab<-gsub("NA","",paste(pData(parameters(rootdata))$name,pData(parameters(rootdata))$desc))
if(!fast){								res<-flowViz:::xyplot(x=form,data=parentdata[,dims2],smooth=smooth,colramp=cols,xlab=xylab[dim.ind[1]],ylab=xylab[dim.ind[2]],frame.plot=TRUE,scales=scales,nbin=512,
										panel=function(gh=x,g=y,tsort=tsort,main=main,...){
											gp <- list(...)[["par.settings"]]
											flowViz:::panel.xyplot.flowframe(...)
											#the gate names sometimes don't match the dimension names.. 
											#If there's a mix of compensated and uncompensated samples.
											dims<-colnames(getBoundaries(gh,g))
											if(.isCompensated(gh)){
											    dims<-dims[na.omit(match((getData(gh,g,tsort=tsort)@parameters@data$name),dims))]
										    }else{
										        tmp<-gsub(">","",gsub("<","",getData(gh,g,tsort=tsort)@parameters@data$name))
										        dims<-colnames(getBoundaries(gh,g))
										        dims<-na.omit(dims[match(tmp,dims)])
										    }
											#Case for rectangle or polygon gate
											if(length(dims)>1){
												panel.polygon(getBoundaries(gh,g)[,dims],border="red",lwd=list(...)$lwd);
											}else{
												apply(getBoundaries(gh,g)[,dims,drop=FALSE],1,function(x)panel.abline(v=x,col="red"))
											}
										},...)
										return(res)
	                                }else{
res<-hexbinplot(form,data=as.data.frame(exprs(parentdata)),colramp=cols,scales=scales,xlim=xlim,ylim=ylim,xlab=xylab[dim.ind[1]],ylab=xylab[dim.ind[2]],aspect=1,xbins=128,panel=function(gh=x,g=y,tsort=tsort,main=main,...){
    panel.hexbinplot(...)
    dims<-colnames(getBoundaries(gh,g))
	if(.isCompensated(gh)){
	    dims<-dims[na.omit(match((getData(gh,g,tsort=tsort)@parameters@data$name),dims))]
    }else{
        tmp<-gsub(">","",gsub("<","",getData(gh,g,tsort=tsort)@parameters@data$name))
        dims<-colnames(getBoundaries(gh,g))
        dims<-na.omit(dims[match(tmp,dims)])
    }
	#Case for rectangle or polygon gate
	if(length(dims)>1){
		panel.polygon(getBoundaries(gh,g)[,dims],border="red",lwd=list(...)$lwd);
	}else{
		apply(getBoundaries(gh,g)[,dims,drop=FALSE],1,function(x)panel.abline(v=x,col="red"))
	}
	
},...)
return(res);
}	    	
		}else{
			if(is.null(getAxisLabels(x)[[dim.ind[1]]])){
				scales<-list();
			}
			else{
				scales<-list(x=list(at=getAxisLabels(x)[[dim.ind[1]]]$at,labels=getAxisLabels(x)[[dim.ind[1]]]$label))
			}
				data=data.frame(exprs(parentdata[,dim.ind]))
				colnames(data)<-flowViz:::expr2char(form[[2]])
								res<-densityplot(x=form,data=data,scales=scales,#prepanel=
								panel=function(...,gh=x,g=y){
									panel.densityplot(...);
									apply(getBoundaries(gh,g)[,dims,drop=FALSE],1,function(x)panel.abline(v=x,col="red"))
								},...)
								return(res)
		}
	}else{
			#add=TRUE
			trellis.focus(highlight=FALSE)
			dims<-colnames(getBoundaries(x,y))
			dims<-dims[na.omit(match((getData(x,y,tsort=tsort)@parameters@data$name),dims))]
			panel.polygon(getBoundaries(x,y)[,dims],border="red",...)
			trellis.unfocus();
		}
	}
})



mkformula<-function(dims2){
	if(length(dims2)==1){
		form<-as.formula(paste(c("",sapply((dims2), function(x) paste("`",x, "`", sep = ""))), collapse = "~"))
	}else{
		form<-as.formula(paste(sapply((dims2),function(x)paste("`",x,"`",sep="")),collapse="~"))
	}
	return(form)
}
#plotgate.panelfun<-function(gh=x,g=y,tsort=tsort,...){
#	gp <- list(...)[["par.settings"]]
#	flowViz:::panel.xyplot.flowframe(...)
#	dims<-colnames(getBoundaries(gh,g))
#	dims<-dims[na.omit(match((getData(gh,g,tsort=tsort)@parameters@data$name),dims))]
#	#Case for rectangle or polygon gate
#	if(length(dims)>1){
#		panel.polygon(getBoundaries(gh,g)[,dims],border="red",lwd=2);
#	}else{
#		apply(getBoundaries(gh,g)[,dims,drop=FALSE],1,function(x)panel.abline(v=x,col="red"))
#	}
#}

setMethod("getPopStats","GatingHierarchy",function(x,...){
	if(!x@flag){
		message("Can't extract population statistics until the data has been gated with 'execute()'\n");
		return()
	}
	
 m<-do.call(rbind,(sapply(RBGL::tsort(x@tree),function(y)list(c(get("fjName",env=nodeData(x@tree,y,"metadata")[[1]]),getProp(x,y),get("count",env=nodeData(x@tree,y,"metadata")[[1]]),get("thisTot",env=nodeData(x@tree,y,"metadata")[[1]]),get("parentTot",env=nodeData(x@tree,y,"metadata")[[1]]),y)))))
	###Fix for root node. Should be fixed in addDataToGatingHierarchy
	rownames(m)<-NULL;
	m<-data.frame(m);
	m[,2]<-as.numeric(as.character(m[,2]));
	m[,3]<-as.numeric(as.character(m[,3]));
	m[,4]<-as.numeric(as.character(m[,4]));
	m[,5]<-as.numeric(as.character(m[,5]))
	m[,6]<-as.character(m[,6])
	
	#m[1,4]<-m[1,3]
	m[1,c(2)]<-1;
	m[1,5]<-m[1,4]
	colnames(m)<-c("pop.name","flowCore.freq","flowJo.count","flowCore.count","parent.total","node")
	rownames(m)<-m[,1]
	m<-m[,2:6]
	m
})

setMethod("getPopStats","GatingSet",function(x,...){
    if(!haveSameGatingHierarchy(x)){
        message("Can't retrieve population statistics table for GatingSet. The samples don't all have the same gating schemes.")
    }
	r<-do.call(cbind,lapply(x,function(y)getPopStats(y)$flowCore.freq))
	rownames(r)<-rownames(getPopStats(x[[1]]));
	r
})

setMethod("plotPopCV","GatingHierarchy",function(x,m=2,n=2,...){
	x<-getPopStats(x)
	cv<-apply(as.matrix(x[,2:3]),1,function(y)IQR(y)/median(y));
	cv<-as.matrix(cv,nrow=length(cv))
	cv[is.nan(cv)]<-0
	rownames(cv)<-basename(as.character(rownames(x)));
	return(barchart(cv,xlab="Coefficient of Variation",...));
})

setMethod("plotPopCV","GatingSet",function(x,...){
#columns are populations
#rows are samples
cv<-do.call(rbind,lapply(lapply(x,getPopStats),function(x)apply(x[,2:3],1,function(x){cv<-IQR(x)/median(x);ifelse(is.nan(cv),0,cv)})))
rownames(cv)<-getSamples(x);#Name the rows
#flatten, generate levels for samples.
nr<-nrow(cv)
nc<-ncol(cv)
populations<-gl(nc,nr,labels=basename(as.character(colnames(cv))))
samples<-as.vector(t(matrix(gl(nr,nc,labels=basename(as.character(rownames(cv)))),nrow=nc)))
cv<-data.frame(cv=as.vector(cv),samples=samples,populations=populations)
return(barchart(cv~populations|samples,cv,...,scale=list(x=list(...))));
})

setMethod("getAxisLabels",signature(obj="GatingHierarchy",y="missing"),function(obj,y=NULL,...){
	get("axis.labels",env=nodeData(obj@tree)[[1]]$data)
})

#to be replaced by method "ncdfFlowSet"
setMethod("getNcdf",signature(obj="GatingSet"),function(obj){
	getNcdf(obj[[1]])
})

#to be replaced by method "ncdfFlowSet"
setMethod("getNcdf",signature(obj="GatingHierarchy"),function(obj){
	.getNcdf(obj)
})

######################################################
#read/update ncdfFlowSet object stored in GatingSet
######################################################
setMethod("ncFlowSet",signature(x="GatingSet"),function(x){
	getNcdf(x[[1]])
})

setMethod("ncFlowSet",signature(x="GatingHierarchy"),function(x){
	.getNcdf(x)
})


setReplaceMethod("ncFlowSet",signature(x="GatingSet"),function(x,value){
	ncFlowSet(x[[1]])<-value
	x
})

setReplaceMethod("ncFlowSet",signature(x="GatingHierarchy"),function(x,value){
			
	if(!inherits(x,"GatingHierarchy")){
		stop("obj must be of class GatingHierarchy")
	}
	if(!x@flag&!x@isNcdf){
		stop("Object doesn't hold ncdf data");
	}
	r<-nodeDataDefaults(x@tree,"data")[["data"]];
	r$ncfs<-value
	x
			
})

##this is to get indice file and the order of nodes instead of indice itself
setMethod("getIndiceFile",signature(obj="GatingHierarchy"),function(obj){
#			browser()
			if(!inherits(obj,"GatingHierarchy")){
				stop("obj must be of class GatingHierarchy")
			}
			if(!obj@flag&obj@isNcdf){
				stop("Must run execute() before fetching data");
			}
			r<-nodeData(obj@tree,getNodes(obj,tsort=FALSE)[1],"data")[[1]];
			if(class(r)=="environment"){
				r$IndiceFile
			}
		})


##THIS METHOD WILL REMOVE ITS CALLING ARGUMENTS FROM THE PARENT ENVIRONMENT UPON EXECUTION AND RETURN A NEW OBJECT.
#IF YOU FORGET TO ASSIGN IT, YOU'RE TOAST.
setMethod("combine",signature("GatingSet","GatingSet"),function(x,y,...){
	if(!haveSameGatingHierarchy(x,y)){
		stop("x and y must have the same gating hierarchy for each sample")
	}
	if(all(unlist(lapply(x,function(xx)flowWorkspace:::isNcdf(xx)),use.names=FALSE))&all(unlist(lapply(y,function(xx)flowWorkspace:::isNcdf(xx)),use.names=FALSE))){
		a<-getNcdf(x);
		b<-getNcdf(y);
		nc3<-rbind2(a,b);
		#create a new gating hierarchy
		G<-new("GatingSet",set=c(x@set,y@set),new("AnnotatedDataFrame",rbind(pData(x),pData(y))))
		ne<-new.env();
		assign("ncfs",nc3,env=ne)
		for(i in seq_along(G))
		{
			flowWorkspace:::setDataEnv(G[[i]],ne)	
		}
		file.remove(c(a@file,b@file))
		#remove the calling objects
		rme<-deparse(substitute(x))
		rm(list=rme,envir=parent.frame())
		rme<-deparse(substitute(y))
		rm(list=rme,envir=parent.frame())
	}else if(all(unlist(lapply(x,function(xx)!flowWorkspace:::isNcdf(xx)),use.names=FALSE))&all(unlist(lapply(y,function(xx)!flowWorkspace:::isNcdf(xx)),use.names=FALSE))){
		fs3<-as(c(as(.getBackingData(x),"list"),as(.getBackingData(y),"list")),"flowSet")
		G<-new("GatingSet",set=c(x@set,y@set),new("AnnotatedDataFrame",rbind(pData(x),pData(y))))
		for(i in seq_along(G))
		{
			flowWorkspace:::setData(G[[i]],fs3[[i]])
		}	
		rm(x,y)
		rme<-deparse(substitute(x))
		rm(list=rme,envir=parent.frame())
		rme<-deparse(substitute(y))
		rm(list=rme,envir=parent.frame())
	}else{
		stop("Can't combine gating sets. They should all use the same storage method. (Netcdf, or not..)")
	}
	return(G);
})

#TODO this method is not complete
setMethod("copyGatingHierarchyFromTo",signature("GatingHierarchy","GatingSet"),function(a,b){
	#The tree strcuture can be copied directly, but the metadata needs to be updated to reflect the new sample
	#get the nodelist and edgelist and add them to the gating hierarchy of gatingset b
	if(haveSameGatingHierarchy(b)){
		for(i in 1:length(b)){
			el<-a@tree@edgeL
			no<-a@tree@nodes
			no[1]<-b[[i]]@nodes[1]
			names(el)<-no
			nd<-a@tree@nodeData
			
			nd@defaults<-b[[i]]@tree@nodeData@defaults
					
			#metadata entries that will be different for each node
			#fcsfile - now in the nodeDataDefaults
			#count
			#compID
			#thisIndices
			#parentTot
			#thisTot
			new.meta<-replicate(length(no),list(list(metadata=new.env())))
			names(new.meta)<-no
			copyEnv(b[[i]]@tree@nodeData@data[[1]]$metadata,new.meta[[1]]$metadata)
			
			#loop to copy each node's info
			for(j in seq_along(new.meta)[-1L]){
				e1<-new.meta[[j]]$metadata
				e2<-nd@data[[j]]$metadata
				copyEnv(e2,e1)
				namval<-c(mget(c("compID"),b[[i]]@tree@nodeData@data[[1]]$metadata),thisIndices=list(),count=NA_character_,isGated=FALSE)
				multiassign(names(namval),namval,e1)
			}
			nd@data<-new.meta
			tmptree<-new("graphNEL",edgeL=el,nodes=no,edgemode="directed")
			tmptree@nodeData<-nd
			b[[i]]@tree<-tmptree
			b[[i]]@nodes<-no
			
			#browser()
			#
			##set metadata
			#finish<-mygate@filterId
			#start<-RBGL::tsort(gr)[2]
			#fjname<-RBGL::sp.between(gr,start,finish)[[1]]$path_detail
			#fjname<-unlist(lapply(strsplit(fjname,"\\."),function(x)x[2]),use.names=FALSE)
			#fjname<-paste("/",paste(fjname,collapse="/"),sep="")
			#nodeData(gr,mygate@filterId,"metadata")<-new.env(parent=emptyenv());
			#assign("fjName",fjname,env=nodeData(gr,mygate@filterId,"metadata")[[1]])
			#assign("gate",mygate,env=nodeData(gr,mygate@filterId,"metadata")[[1]])
			#assign("fcsfile",fcsfile,env=nodeDataDefaults(gr,"metadata"))
			#assign("count",count,env=nodeData(gr,mygate@filterId,"metadata")[[1]])
			#assign("compID",compID,env=nodeData(gr,mygate@filterId,"metadata")[[1]])
			#assign("negated",ng,env=nodeData(gr,mygate@filterId,"metadata")[[1]])
			#assign("isBooleanGate",FALSE,env=nodeData(gr,mygate@filterId,"metadata")[[1]])
			#assign("thisIndices",list(),env=nodeData(gr,mygate@filterId,"metadata")[[1]])
			#assign("parentTot",NA,env=nodeData(gr,mygate@filterId,"metadata")[[1]])
			#assign("thisTot",0,env=nodeData(gr,mygate@filterId,"metadata")[[1]])
			##20110314
			#assign("isGated",FALSE,env=nodeData(gr,mygate@filterId,"metadata")[[1]])
			#assign("gr",gr,env=env);				
		}
	}
	#node-specific metadata - need to update (ie. gates)
	#hierarchy-specific environments - defaults exist already. should not need to change
	#gatingset - global metadata - also exists already should not need to change it
	return(b);
})
recomputeGatingSet<-function(x){
	flowCore:::checkClass(x,"GatingSet")
	stopifnot(haveSameGatingHierarchy(x))
	if(any(grepl("multicore",loadedNamespaces()))){
	    result<-multicore::mclapply(as.list(seq_along(x)),function(i){
	        for(j in which(nodes(x[[i]]@tree)%in%leaves(x[[i]]@tree,"out"))){
	            flowWorkspace:::recomputeGate(x[i],j,boolean=NULL)
	            ##construct and return a 'call' that will set up the environment of the gating set upon returning.
	        }
	        flowWorkspace:::writeGatesToNetCDF(x[[i]]);
	        tmp<-x[[i]]@tree@nodeData@data
	        calls<-vector("list",length(x[[i]]@nodes))
	        names(calls)<-x[[i]]@nodes
	        for(j in seq_along(x[[i]]@nodes)){
	            calls[[j]]<-list(multiassign,x=ls(tmp[[j]]$metadata),value=mget(ls(tmp[[j]]$metadata),tmp[[j]]$metadata))
            }
            calls
	    })
	    for(i in seq_along(result)){
	        for(j in seq_along(result[[i]])){
	            eval(as.call(c(result[[i]][[j]],envir=x[[i]]@tree@nodeData@data[[j]]$metadata)))
	        }
	    }
	}else{
	for(i in seq_along(x)){sapply(which(nodes(x[[i]]@tree)%in%leaves(x[[i]]@tree,"out")),function(j){recomputeGate(x[i],j,boolean=NULL);flowWorkspace:::writeGatesToNetCDF(x[[i]])})}
    }
	invisible(NULL)
}

setAs("GatingSet","list",function(from){l<-vector("list",length(from));
for (i in seq_along(l)){
l[[i]]<-from[[i]]
}
l})

recomputeGate<-function(x,gate,boolean=FALSE){
	flowCore:::checkClass(x,"GatingSet")
	flowCore:::checkClass(gate,"numeric")
	if(gate>length(flowWorkspace:::getNodes(x[[1]])))
	stop("gate index ",gate," out of range");
	
	#Start by setting the "isGated" flag to FALSE for this gate in all the gating hierarchies.
	#recalculate the gate
	#don't assign to the ncdf file or we'll lose the original gating info for comparison!
		lapply(as(x,"list"),function(gh){node<-flowWorkspace:::getNodes(gh)[gate];
			assign("isGated",FALSE,env=nodeData(gh@tree,node,"metadata")[[1]])
			if(is.null(boolean)){
				if(flowWorkspace:::.isBooleanGate.graphNEL(gh,node)){
					flowWorkspace:::.calcBooleanGate(gh,node)
				}else{
					flowWorkspace:::.calcGate(gh,node,force=TRUE)	
				}
			}else if(!boolean){
				flowWorkspace:::.calcGate(gh,node,force=TRUE)	
			}else{
				flowWorkspace:::.calcBooleanGate(gh,node)
			}
		})
		
}

setMethod("getData",signature(obj="graphNEL"),function(obj,y=NULL,tsort=FALSE){
    mpiflag<-FALSE;
    #message("do we have the token? ",options("flowWorkspace_mpi_read_token")[[1]], " mpiflag: ",mpiflag)
	if(!is.null(options("flowWorkspace_mpi_communication")[[1]])){
	    if(options("flowWorkspace_mpi_communication")[[1]]){
	        if(!options("flowWorkspace_mpi_read_token")[[1]]){
	        mpiflag<-TRUE
	        #ask permission to read
            #message("getData: want to read")
	        mpi.send.Robj(0,0,10)
	        #have the token
            #message("getData: waiting for the token")
	        mpi.recv.Robj(0,11)
	        options("flowWorkspace_mpi_read_token"=TRUE)
            #message("getData:flowWorkspace_mpi_read_token ",options("flowWorkspace_mpi_read_token")[[1]])
        }
        }
    }
			y<-nodes(obj)[1];
			r<-nodeData(obj,y,"data")[[1]][["data"]]
			if(class(r)=="environment")
				r<-r$ncfs[[getSample(obj)]]
            #message("mpiflag ",mpiflag)
			if(mpiflag){
                #message("done reading")
			    options("flowWorkspace_mpi_read_token"=FALSE)
			    mpi.send.Robj(0,0,12)
                #message("message sent")
		    }
			r
		})

.getNcdf<-function(obj){
	if(!inherits(obj,"GatingHierarchy")){
		stop("obj must be of class GatingHierarchy")
	}
	if(!obj@flag&!obj@isNcdf){
		stop("Object doesn't hold ncdf data");
	}
	r<-nodeDataDefaults(obj@tree,"data")[["data"]];
	if(class(r)=="environment"){
		r$ncfs
	}
}
.getBackingData<-function(obj){
	if(inherits(obj,"GatingHierarchy")){
	    if(obj@flag&!obj@isNcdf){
    		if(!obj@isNcdf){
    			r<-nodeDataDefaults(obj@tree,"data")[["data"]];
    		}else{
    			stop(".getBackingData: something is wrong")
    		}
    		if(class(r)=="environment"&obj@isNcdf){
        		return(r$ncfs)
        	}else if(class(r)=="environment"&!obj@isNcdf){
        	    return(r$data)
        	}else{
        	    return(r)
        	}
    	}
	}else if(inherits(obj,"GatingSet")){
	    r<-lapply(obj,.getBackingData)
	}
}


setMethod("getData",signature(obj="GatingHierarchy"),function(obj,y=NULL,tsort=FALSE){
	if(!obj@flag){
		stop("Must run execute() before fetching data");
	}
	mpiflag<-FALSE;
    #message("do we have the token? ",options("flowWorkspace_mpi_read_token")[[1]], " mpiflag: ",mpiflag)
	if(!is.null(options("flowWorkspace_mpi_communication")[[1]])){
	    if(options("flowWorkspace_mpi_communication")[[1]]){
	        if(!options("flowWorkspace_mpi_read_token")[[1]]){
	        mpiflag<-TRUE
	        #ask permission to read
            #message("getData(GH): want to read")
	        mpi.send.Robj(0,0,10)
	        #have the token
            #message("getData(GH): waiting for  token")
	        mpi.recv.Robj(0,11)
	        options("flowWorkspace_mpi_read_token"=TRUE)
            #message("getData:flowWorkspace_mpi_read_token ",options("flowWorkspace_mpi_read_token")[[1]])
            }
        }
    }
	if(is.null(y)){
		r<-nodeData(obj@tree,getNodes(obj,tsort=tsort)[1],"data")[[1]][["data"]]
		if(class(r)=="environment")
			r<-r$ncfs[[getSample(obj)]]
	}else if(identical(y,getNodes(obj)[1])){
		r<-nodeData(obj@tree,getNodes(obj,tsort=tsort)[1],"data")[[1]][["data"]]
		if(class(r)=="environment")
			r<-r$ncfs[[getSample(obj)]]
	}else if(is.numeric(y)){
		n<-getNodes(obj,tsort=tsort)[y]
		r<-getData(obj,n,tsort=tsort);
	}else{
		r<-nodeData(obj@tree,y,"data")[[1]][["data"]]
		if(class(r)=="environment")
			r<-r$ncfs[[getSample(obj)]]
		r<-r[getIndices(obj,y),]
	}
    #message("mpiflag ",mpiflag)
	if(mpiflag){
	    options("flowWorkspace_mpi_read_token"=FALSE)
        #message("reply that we're done reading")
	    mpi.send.Robj(0,0,12);
        #message("reply sent")
	}
	r
})
setMethod("getData",signature(obj="GatingSet"),function(obj,y=NULL,tsort=FALSE){
	if(is.null(y)){
		return(flowSet(lapply(obj,function(x)getData(x,tsort=tsort))))
	}else if(is.numeric(y)){
		return(flowSet(lapply(obj,function(x)getData(x,y,tsort=tsort))))
	}else{
		stop("Invalid value for y. Must be class \"numeric\"");
	}
})
setMethod("getKeywords",signature("flowJoWorkspace","character"),function(obj,y){
	w <- which(xpathApply(obj@doc,"/Workspace/SampleList/Sample/Keywords/Keyword[@name='$FIL']",function(x)xmlGetAttr(x,"value"))%in%y)
	l<-xpathApply(obj@doc,paste("/Workspace/SampleList/Sample[",w,"]/Keywords/node()",sep=""),xmlAttrs)
	names(l)<-lapply(l,function(x)x[["name"]])
	l<-lapply(l,function(x)x[["value"]])
	return(l);
})

.getKeyword<-function(ws,x){
	if(inherits(ws,"flowJoWorkspace")&class(x)=="character"){
		 unlist(xpathApply(ws@doc,paste("/Workspace/SampleList/Sample/Keywords/Keyword[@name='",x,"']",sep=""),function(x)xmlGetAttr(x,"value")),use.names=FALSE)
	}else{
		stop("No such keyword")
	}
	
}

setMethod("Subset",signature=signature(x="GatingSet",subset="numeric"),
	definition=function(x,subset,select,...){
		if(!all(unlist(lapply(lapply(x,function(x)getNodes(x)),function(x)length(x)>subset),use.names=FALSE))){
			stop("subset out of range");
		}
		ncfs<-ncdfFlow::clone.ncdfFlowSet(flowWorkspace:::getNcdf(x[[1]]),isNew=FALSE,isEmpty=FALSE)
		s<-getSamples(x) #Use GatingSet sample order, not ncdfFlowSet sample order (they are different, but same names)
		for(i in 1:length(s)){
			ind<-getIndices(x[[i]],getNodes(x[[i]])[subset])
			updateIndices(x=ncfs,y=s[i],z=ind);
		}
		return(ncfs[s])
	})
getFJWSubsetIndices<-function(ws,key=NULL,value=NULL,group,requiregates=TRUE){
	if(!is.numeric(group)){
		stop("group must be numeric")
	}
	if(!is.character(key)&!is.null(key)){
		stop("keyword must be character")
	}
	if(!is.character(value)&!is.null(value)){
		stop("value must be character")
	}
	if(!class(ws)=="flowJoWorkspace"){
		stop("ws must be a flowJoWorkspace object")
	}
	s<-getSamples(ws);
	#TODO Use the actual value of key to name the column
	if(!is.null(key)){
	s$key<-flowWorkspace:::.getKeyword(ws,key)
	}
	g<-getSampleGroups(ws)
	sg<-merge(s,g,by="sampleID")
	if(requiregates){
	sg<-sg[sg$pop.counts>0,]
	}
	sg$groupName<-factor(sg$groupName)
	groups<-levels(sg$groupName)
	if(group>length(groups)){
		stop("group is invalid, out of range")
	}
	sg<-sg[sg$groupName%in%groups[group],]
	if(!is.null(key)&!is.null(value)){
	return(which(sg$key%in%value))
	}
	return(sg)
}

.getKeywords<-function(doc,y){
	w<-which(xpathApply(doc,"/Workspace/SampleList/Sample/Keywords/Keyword[@name='$FIL']",function(x)xmlGetAttr(x,"value"))%in%y)
	if(length(w)==0){
		warning("Sample ",y," not found in Keywords");
		##Use the DataSet tag to locate the sample
		w<-which(xpathApply(doc,"/Workspace/SampleList/Sample/DataSet",function(x)xmlGetAttr(x,"uri"))%in%y)
	}
	l<-xpathApply(doc,paste("/Workspace/SampleList/Sample[",w,"]/Keywords/node()",sep=""),xmlAttrs)
	names(l)<-lapply(l,function(x)x[["name"]])
	l<-lapply(l,function(x)x[["value"]])
	return(l)
}

setMethod("getKeywords",signature("GatingHierarchy","missing"),function(obj,y){
	get("keywords",env=nodeData(obj@tree)[[1]]$metadata);
})
#Return the list of keywords given a GatingSet and a sample name
setMethod("getKeywords",signature("GatingSet","character"),function(obj,y){
	ind<-which(getSamples(obj)%in%y)
	if(length(ind)>0){
		getKeywords(obj,ind);
	}else{
		stop(paste("Sample ",y," not in GatingSet",sep=""));
	}
})
setMethod("getKeywords",signature("GatingSet","numeric"),function(obj,y){
	if(length(obj)<y){
		stop("index out of range");
	}else{
		getKeywords(obj[[y]]);
	}
})
#Return the value of the keyword given a flowWorkspace and the keyword name
setMethod("keyword",signature("GatingHierarchy","character"),function(object,keyword){
	kw<-as.environment(getKeywords(object))
	mget(keyword,kw);
})
setMethod("keyword",signature("GatingSet","character"),function(object,keyword){
	tmp<-data.frame(unlist(lapply(object,function(x)keyword(x,keyword)),use.names=FALSE));
	tmp<-data.frame(matrix(tmp[[1]],ncol=length(keyword),byrow=T))
	colnames(tmp)<-keyword
	tmp
})
setMethod("getGate",signature(obj="GatingHierarchy",y="character"),function(obj,y){
	if(.isBooleanGate.graphNEL(obj,y)){
		g<-get("gate",env=nodeData(obj@tree,y,"metadata")[[1]])[[1]];
		return(g)
	}else{
		return(get("gate",env=nodeData(obj@tree,y,"metadata")[[1]]))
	}
})
#return gate y for a given hierarchy (by index)
setMethod("getGate",signature(obj="GatingHierarchy",y="numeric"),function(obj,y,tsort=FALSE){
	n<-getNodes(obj,tsort=tsort)[y]
	if(flowWorkspace:::.isBooleanGate.graphNEL(obj,n)){
		g<-get("gate",env=nodeData(obj@tree,n,"metadata")[[1]])[[1]]
		return(g);
	}else{
		return(get("gate",env=nodeData(obj@tree,n,"metadata")[[1]]))
	}
})
#Return gate y for all samples in the gating set (by index).
#Warning: assume that all gating hierarchies are the same in the given gating set. We don't check for this, so be careful.
setMethod("getGate",signature(obj="GatingSet",y="numeric"),function(obj,y,tsort=FALSE){
	lapply(obj,function(x)getGate(x,y,tsort=tsort))
})
setMethod("getParent",signature(obj="GatingHierarchy",y="numeric"),function(obj,y,tsort=FALSE){
	return(match(getParent(obj,getNodes(obj,tsort=tsort)[y]),getNodes(obj,tsort=tsort)));
})
setMethod("getParent",signature(obj="GatingHierarchy",y="character"),function(obj,y){
	setdiff(adj(ugraph(obj@tree),y)[[1]],adj(obj@tree,y)[[1]])
})
setMethod("getBoundaries",signature(obj="GatingHierarchy",y="character"),function(obj,y){
	g<-getGate(obj,y);
	if(length(g@parameters)==1){
		rbind(g@min,g@max)
	}else{
		g@boundaries
	}
})

#Bug here when the GatingSet has a mix of compensated and uncompensated data.. maybe need a isCompensated method..
.isCompensated<-function(x){
    flowCore:::checkClass(x,"GatingHierarchy")
    !(is.null(rownames(x@compensation))&identical(x@compensation%*%x@compensation,x@compensation))
}
setMethod("getDimensions",signature(obj="GatingHierarchy",y="character"),function(obj,y,index=FALSE){
	if(.isBooleanGate.graphNEL(obj,y)){
		getDimensions(obj,getParent(obj,y),index=index);
	}else{
		if(!index){
			if(length(getGate(obj,y)@parameters)==1){
				c(getGate(obj,y)@parameters[[1]]@parameters);
			}else{
				c(getGate(obj,y)@parameters[[1]]@parameters,getGate(obj,y)@parameters[[2]]@parameters)
			}
		}else{
				if(length(getGate(obj,y)@parameters)==1){
				    if(.isCompensated(obj)){
				        tmp<-parameters(getData(obj,y))@data$name
				    }else{
				        tmp<-gsub(">","",gsub("<","",parameters(getData(obj,y))@data$name))
				    }
					c(match(getGate(obj,y)@parameters[[1]]@parameters,tmp))	
				}else{
                    if(.isCompensated(obj)){
				        tmp<-parameters(getData(obj,y))@data$name
				    }else{
				        tmp<-gsub(">","",gsub("<","",parameters(getData(obj,y))@data$name))
				    }
   c(match(getGate(obj,y)@parameters[[1]]@parameters,tmp),match(getGate(obj,y)@parameters[[2]]@parameters,tmp))
				}
			}
	}
})


setMethod("getIndices",signature(obj="GatingHierarchy",y="character"),function(obj,y){
#	browser()
		if(.isBooleanGate.graphNEL(obj,y)){
		g<-get("gate",env=nodeData(obj@tree,y,"metadata")[[1]])[[1]]
		if(length(g$ref)==1){
			p<-paste("getIndices(obj,\"",g$ref,"\")",sep="")
			p<-paste(g$v,p,sep="")
	 		parent<-getParent(obj,y)
			p<-c("flowWorkspace::getIndices(obj,parent)&(",p,")");
			ret<-eval(parse(text=paste(p,collapse="")))
			return(ret)
		}else{
			p<-paste("getIndices(obj,\"",g$ref,"\")",sep="")
	 		p<-paste(g$v,p,sep="")
			p<-paste(p,c(g$v2,""),sep="")
			parent<-getParent(obj,y)
			p<-c("flowWorkspace::getIndices(obj,parent)&(",p,")");
			ret<-eval(parse(text=paste(p,collapse="")))
			return(ret)
		}
	}else{
		if(y==getNodes(obj)[1]){
			ret<-try(rep(TRUE,nodeData(obj@tree,y,"metadata")[[1]][["thisTot"]]))
			if(inherits(ret,"try-error"))
			    warning("count still emtpy!")
			    #browser()
			return(ret)
		}else{
			#20110314 if not gated yet,then do the gating first 
			#if(!.isGated.graphNEL(obj,y))
			#{
				#check is now inside .calcGate
				.calcGate(obj,y)
			#}
			ret<-get("thisIndices",env=nodeData(obj@tree,y,"metadata")[[1]])[[1]]
			
			if(is.null(ret))##load bit-vector indice from file
			{
				nl<-getNodes(obj)[sapply(getNodes(obj),function(x)!flowWorkspace:::.isBooleanGate.graphNEL(obj,x))]				
				ret<-ncdfFlow:::readIndice(list(nlist=nl,ncFile=getIndiceFile(obj)),Node=y)
				
			}
			##remove isRaw and always return logical vector to
			##reduce potential mistakes
			if(class(ret)=="raw") 
				ret<-.getBitStatus(ret)
			
			return(ret)
		}
	}
})



###write indice which is a bitvector 
setMethod("writeIndice",signature(obj="GatingHierarchy",y="character",z="raw"),function(obj,y,z){

			##convert bitvector to matrix before call ncdfFlow API
			indiceMat<-as.matrix(z)
			attr(indiceMat,"bitlen")<-attr(z,"bitlen")
			attr(indiceMat,"nbitset")<-attr(z,"nbitset")
			nl<-getNodes(obj)[sapply(getNodes(obj),function(x)!flowWorkspace:::.isBooleanGate.graphNEL(obj,x))]	
			ncdfFlow:::writeIndice(list(nlist=nl,ncFile=getIndiceFile(obj)),indiceMat,startNode=y)		
				
		})

###write indice which is a logical vector 
setMethod("writeIndice",signature(obj="GatingHierarchy",y="character",z="logical"),function(obj,y,z){
			##convert logical vector to bitvector
			z<-.makeBitVec(length(z),z)
			writeIndice(obj,y,z)
		})

###write indices which is a list of vectors 
setMethod("writeIndice",signature(obj="GatingHierarchy",y="character",z="list"),function(obj,y,z){
#			browser()
			for(i in 1:length(y))
			{
				curNode<-y[i]
				curIndice<-z[[i]]
				writeIndice(obj,curNode,curIndice)
			}
			
		})
setMethod("getChildren",signature(obj="GatingHierarchy",y="character"),function(obj,y){
	adj(obj@tree,y)[[1]]
})

setMethod("getProp",signature(x="GatingHierarchy",y="character"),function(x,y){
	#Return the proportion of the population relative to the parent and relative to the total.
	#x is a graph of a gating hierarchy that has had data added to it.
	#y is nodename
		return(get("thisTot",env=nodeData(x@tree,y,"metadata")[[1]])/get("parentTot",env=nodeData(x@tree,y,"metadata")[[1]]))	
})
setMethod("getTotal",signature(x="GatingHierarchy",y="character"),function(x,y){
		return(get("thisTot",env=nodeData(x@tree,y,"metadata")[[1]]))
})


.getGains<-function(x){
	##Sometimes the gains are not in the keywords but in the Parameter section of the sample. Where do they come from? Only flowJo knows..
	n<-as.numeric(xmlGetAttr(xpathApply(x,"./ancestor::Sample/Keywords/Keyword[@name='$PAR']")[[1]],"value"));
	t(sapply(1:n,function(i){
		cn<-paste("$P",i,"N",sep="")
		cg<-paste("$P",i,"G",sep="");
		cnquery<-paste("./ancestor::Sample/Keywords/Keyword[@name='",cn,"']",sep="");
		cgquery<-paste("./ancestor::Sample/Keywords/Keyword[@name='",cg,"']",sep="");
		cname<-xpathApply(x,cnquery,function(q)xmlGetAttr(q,"value"))[[1]];
		cgain<-xpathApply(x,cgquery,function(q)xmlGetAttr(q,"value",default=NA));
		#Test if we found it
		if(length(cgain)!=0){
			cgain<-as.numeric(cgain[[1]])
		}else{
			#Otherwise look for the gain elsewhere.
			cgain<-xpathApply(x,paste("./ancestor::Sample/Parameter[",i,"]",sep=""),function(q)xmlGetAttr(q,"gain"));
			if(length(cgain)!=0){
				cgain<-as.numeric(cgain[[1]])
			}else{
				stop("Oops! Can't find the GAIN for parameter ",cname);
			}
		}
		c(cname,cgain);
	}))
}
# ===================================================================================
# = Convert rectangular to polar coordinates. Rows are data points, columns are x,y =
# ===================================================================================
.rectangular2polar<-function(points,center){
	dif<-t(t(points)-center);
	radians<-atan(dif[,2]/dif[,1])
	radius <- sqrt(apply(dif^2,1,sum))
	list(radius=radius,radians=radians)
}
# =============================
# = Given the angle, X, and Y =
# = X is rightmost, Y is 	  =
# + Y is leftmost point 	  =
# = Centered at 0,0           =
# =============================
.ellipse2Cov<-function(angle,Xdim,Ydim){	
	CxxI<-cos(angle)^2/Xdim^2+sin(angle)^2/Ydim^2;
	CyyI<-sin(angle)^2/Xdim^2+cos(angle)^2/Ydim^2;
	CxyI<-sin(angle)*cos(angle)*(1/Xdim^2-1/Ydim^2)
	C<-solve(matrix(c(CxxI,CxyI,CxyI,CyyI),ncol=2))
	C/qchisq(0.95,2);
}
# =======================================================
# = This function is adapted from the ellipse package.  =
# = Outputs bottom, top, right, and left most points on =
# = the ellipse given by the covariance matrix		    =
# = The level argument specifies the % contour.			=
# = scale should not be used.							=
# =======================================================
.cov2Ellipse<-function (x, scale = c(1, 1), centre = c(0, 0), level = 0.95, 
    t = sqrt(qchisq(level, 2)), which = c(1, 2),...) 
{
    names <- c("x", "y")
    if (is.matrix(x)) {
        xind <- which[1]
        yind <- which[2]
        r <- x[xind, yind]
        if (missing(scale)) {
            scale <- sqrt(c(x[xind, xind], x[yind, yind]))
            if (scale[1] > 0) 
                r <-r/scale[1]
            if (scale[2] > 0) 
                r <- r/scale[2]
        }
        if (!is.null(dimnames(x)[[1]])) 
            names <- dimnames(x)[[1]][c(xind, yind)]
    }
    else r <- x
    r <- min(max(r, -1), 1)
    d <- acos(r)
    a <- c(3/2*pi,pi/2,0,pi)
    matrix(c(t * scale[1] * cos(a + d/2) + centre[1], t * scale[2] * 
        cos(a - d/2) + centre[2]), 4, 2, dimnames = list(NULL, 
        names))
}
# =============================================================================
# = S4 method for converting and ellipsoid gate to vertices for flowJo export =
# =============================================================================
setMethod("ellipsoidGate2FlowJoVertices",signature(gate="ellipsoidGate"),function(gate,level=0.95,...){
	vertices<-.cov2Ellipse(gate@cov,level=level,centre=gate@mean);
	colnames(vertices)<-parameters(gate);
	vertices;
})
.ellipseFit<-function(x,l=100){
	if(all(dim(x)!=c(4,2))){
		stop("Coordinates of the ellipse gate are not as expected. Was expecting 4x2 matrix but got ",dim(x))
	}else{
		R<-x[which.max(x[,1]),]
		L<-x[which.min(x[,1]),]
		T<-x[which.max(x[,2]),]
		B<-x[which.min(x[,2]),]
		E<-c(norm(as.matrix(L-R),"F"),norm(as.matrix(T-B),"F"))/2
		phi<-tan((R-L)[2]/(R-L)[1])
		CY<-(B[2]+T[2])/2
		CX<-(R[1]+L[1])/2
		S<-seq(0,2*pi,l=l)
		X<-CX+E[1]*cos(S)*cos(phi)-E[2]*sin(S)*sin(phi);
		Y<-CY+E[1]*cos(S)*sin(phi)+E[2]*sin(S)*cos(phi);
		return(data.frame(x=X,y=Y));
	}
}
.booleanGate<-function(x,y){
	#X is a graph
	##Y is a list of nodes
	##Will output all possible combinations of the supplied gates
	tt<-rep(list(c(TRUE,FALSE)),length(y));
	names(tt)<-y;
	tt<-expand.grid(tt);
	len<-length(getIndices(x,y[1]))
	ind<-sapply(y,function(q){getIndices(x,q)})
	r<-matrix(TRUE,len,dim(tt)[1])
	for(q in 1:dim(tt)[1]){
		pos<-y[which(tt[q,]==TRUE)]
		neg<-y[which(tt[q,]==FALSE)]
		r[,q]<-tryCatch(.bGate(ind[,pos]),error=function(x)matrix(rep(TRUE,len),ncol=1))&tryCatch(.bGate(!ind[,neg]),error=function(x)matrix(rep(TRUE,len),ncol=1))
	}
	gates<-sapply(y,function(y)getGate(x,y))
	nnames<-names(gates)
	dims<-sapply(nnames,function(y)getDimensions(x,y));
	dlevels<-factor(apply(dims,2,function(x)paste(x,collapse=":")))
	udims<-length(unique(as.vector(dims)))
	for(i in 1:ncol(r)){
		d<-getData(x,y[1])[r[,i],udims]
	}
}

.bGate<-function(X){
	nc<-dim(X)[2];
	if(nc==2){
		return(X[,1]&X[,2])
	}
	else{
		return(X[,1]&Recall(X[,-(1)]))
	}
}


.mergetables<-function(...){
	l<-as.list(...)
	if(length(l)==1){
		return(l[[1]]);
	}else{
	  return(.mergetables(c(list(merge(l[[1]],l[[2]],by="pop.name",all=TRUE)),l[-c(1:2)])))
	}
}

#20110314
.isGated.graphNEL<-function(x,y){
	return(get("isGated",env=nodeData(x@tree,y,"metadata")[[1]]));
}

.nextPopulation<-function(x,level){
	#Get all the population nodes one level below this one..
	xpathApply(x,paste("./descendant::Population[count(ancestor-or-self::Population) = ",level+xpathApply(x,"count(ancestor-or-self::Population)"),"]",sep=""));
}
.getPopulations<-function(x,env=NULL,includegates=TRUE){
	#TODO could change the class to use a graphBAM and just generate an adjacency list here.
	#TODO set up the node data list
	#Construct the graph at the end, and set the flowJo names later.
	#This may be significantly faster.
	 
	#Things to do the first time we encounter a sample
	if(is.null(env)){
		env=new.env(parent=globalenv());
		assign("groups",.getSampleGroups(xmlRoot(x),win=FALSE),env=env);
		assign("gr",new("graphNEL",edgemode="directed"),env=env)
		gr<-get("gr",env)
		nodeDataDefaults(gr,"metadata")<-new.env(parent=emptyenv());
		#Store the compensation matrices
		if(is.null(xpathApply(x,"./ancestor-or-self::Sample",function(x)xmlGetAttr(x,"compensationID"))[[1]])){
			#No compensation matrix
			#Here the matrix could be acquisition defined and stored in the spillover keyword, but the data is also stored compensated so it doesn't need to be applied.
			spillover.matrix<-try(strsplit(xpathApply(x,"./ancestor-or-self::Sample/Keywords/Keyword[@name='SPILL']",function(x)xmlGetAttr(x,"value"))[[1]],",")[[1]],silent=TRUE);
			if(!inherits(spillover.matrix,"try-error")){
				dims<-as.numeric(spillover.matrix[1]);
				spillover.matrix<-spillover.matrix[-1L]
				cn<-spillover.matrix[1:dims];
				spillover.matrix<-matrix(as.numeric(spillover.matrix[-c(1:dims)]),byrow=TRUE,ncol=dims)
				colnames(spillover.matrix)<-cn;
				compensation<-spillover.matrix
			}else{
				compensation<-matrix();
			}
			
			assign("compensation",compensation,env);
		}else{
			compID<-xpathApply(x,"./ancestor-or-self::Sample",function(x)xmlGetAttr(x,"compensationID"))[[1]]
			if(compID!=-1 & compID!=-2){
				compobj<-.getCompensationMatrices(xmlRoot(x))[[as.numeric(compID)]]
				assign("compensation",compobj,env);
			}else if(compID==-1){
				#WARNING there may be cases where this still does not work (i.e. the Acquisition-Defnined string is not there)
				assign("compensation",as.matrix("Acquisition-defined"),env);
			}
		}
		assign("gr",gr,env=env);
		assign("env",env,env=globalenv())
		#get the SampleNode for this sample
		x<-xpathApply(x,"./SampleNode")[[1]]
	}
	#If we are at a SampleNode
	if(.isSampleNode(x)){
		#Initialize the sample so that things work even if there are no gates defined
		root<-xmlGetAttr(x,"name")
		rootcount<-xmlGetAttr(x,"count")###
		#####Fix a bug here. If "count" is empty or doesn't exist, need to look at the parent Sample xml node and get the eventCount property
		if(is.null(rootcount)){
		    rootcount<-xpathApply(x,"./ancestor::Sample",function(x)xmlGetAttr(x,"eventCount"))[[1]]
		}
		parentpop<-root
		if(is.na(match(parentpop,nodes(get("gr",env=env))))){
			assign("gr",graph::addNode(parentpop,get("gr",env=env)),env=env)
		
			gr<-get("gr",env=env)
			nodeData(gr,parentpop,"metadata")<-new.env(parent=emptyenv());
			assign("count",rootcount,env=nodeData(gr,parentpop,"metadata")[[1]]);
			compID<-xpathApply(x,"./ancestor::Sample",function(x)xmlGetAttr(x,"compensationID"))[[1]];
			if(is.null(compID)){
				# -2 means there's no compensation ID
				compID<--2;
			}
			fcsfile<- unlist(tryCatch(xpathApply(x,"./ancestor::Sample/Keywords/Keyword[@name='$FIL']",function(z)xmlGetAttr(z,"value")),error=function(q)NA),use.names=FALSE)
			assign("fcsfile",fcsfile,env=nodeDataDefaults(gr,"metadata"));
			#More root node defaults
			##get keywords and assign keywords
			kw<-.getKeywords(x,fcsfile);
multiassign(c("compID","fjName","gate","negated","isBooleanGate","thisIndices","parentTot","thisTot","isGated","keywords"),list(compID,fcsfile,NA,FALSE,FALSE,list(),NA,0,FALSE,kw),env=nodeData(gr,parentpop,"metadata")[[1]])
			assign("gr",gr,env=env)
		}
		#Now construct the transformations
		constructTransformations(x,env)
	}
	##If we're at a population node
	if(includegates){
	if(.isPopulation(x)){		
		parentpop <- tryCatch(rev(xpathApply(x,"./ancestor::Population",xmlAttrs))[[1]][["name"]],error= function(x) NA );
		root<-xpathApply(x,"./ancestor::SampleNode",function(x)xmlGetAttr(x,"name"))[[1]];
		rootcount<-xpathApply(x,"./ancestor::SampleNode",function(x)xmlGetAttr(x,"count"))[[1]];
		if(is.null(rootcount)){
		    rootcount<-xpathApply(x,"./ancestor::Sample",function(x)xmlGetAttr(x,"eventCount"))[[1]]
		}
		
		if(!is.na(parentpop)){	
			parent.nn<-tryCatch(rev(xpathApply(x,"./ancestor::Population",xmlAttrs))[[1]][["nn"]],error=function(x)NA)
			parentpop<-paste(parent.nn,parentpop,sep=".");
		}else{
			parentpop<-root
		}
		#If there's a gate below this population and it's not a boolean gate proceed as before
		if(.hasGate(x)&!.isBooleanGate(x)){
			#Extract the gate
			mygate<-.extractGate(x,env=env);
			ng<-mygate[[2]] ##Is this gate negated?
			mygate<-mygate[[1]]
				
			#Assign the node to the graph
			assign("gr",graph::addNode(mygate@filterId,get("gr",env=env)),env=env);
			#And add an edge to the parent.
			assign("gr",addEdge(parentpop,mygate@filterId,get("gr",env=env)),env=env);
			#Pull the filename from the keywords
			# fcsfile<- unlist(tryCatch(xpathApply(x,"./ancestor::Sample/Keywords/Keyword[@name='$FIL']",function(z)xmlGetAttr(z,"value")),error=function(q)NA),use.names=FALSE)

			#The node metadata is node-specific and has to be pulled for each node. That's why the assignments below are replicated.
			compID<-xpathApply(x,"./ancestor::Sample",function(x)xmlGetAttr(x,"compensationID"))[[1]];
			if(is.null(compID)){
				compID<--2;
			}
			count<-xmlGetAttr(x,"count");
			# Presume that a NULL count is for empty pops.
			if(is.null(count))
				count<-0
			gr<-get("gr",env=env)
			##get the flowJo name for the current population
			##Generate the flowJo population name
			finish<-mygate@filterId
			start<-RBGL::tsort(gr)[2]
			fjname<-RBGL::sp.between(gr,start,finish)[[1]]$path_detail
			fjname<-unlist(lapply(strsplit(fjname,"\\."),function(x)x[2]),use.names=FALSE)
			fjname<-paste("/",paste(fjname,collapse="/"),sep="")
			nodeData(gr,mygate@filterId,"metadata")<-new.env(parent=emptyenv());
			multiassign(c("fjName","gate","count","compID","negated","isBooleanGate","thisIndices","parentTot","thisTot","isGated"),list(fjname,mygate,count,compID,ng,FALSE,list(),NA,0,FALSE),env=nodeData(gr,mygate@filterId,"metadata")[[1]]);
			assign("gr",gr,env=env);	
		}
		#If it is a boolean gate.
		else if(.hasGate(x)&.isBooleanGate(x)){
			#we want to parse it and add it to the gating hierarchy. But we don't want to evaluate the counts just yet.
			gr<-get("gr",env=env)
			gr<-.parseBooleanGates(x,gr)
			assign("gr",gr,env=env);
		}
	}
	#TODO could change this to be a global loop that simply goes through all the children that are populations and ignores everything else.. 
	nxt<-.nextPopulation(x,1)
		if(length(nxt)!=0){
			lapply(nxt,function(x).getPopulations(x,env=env,includegates=includegates))	
		}
	}
	return();
}

.hasGate<-function(x){
	(length(xpathApply(x,"./child::PolygonGate|./child::BooleanGate"))!=0)
}
.hasGate_1.6<-function(x){
	(length(xpathApply(x,"./child::Gate"))!=0)
}
.isSampleNode<-function(x){
	xmlName(x)=="SampleNode"
}
.isPopulation<-function(x){
	xmlName(x)=="Population"
}
##Familiar tree accessor methods
.hasChildren<-function(x){
	length(xmlChildren(x))!=0
}
.children<-function(x){
	if(.hasChildren(x)){
		xmlChildren(x);
	}else{
		NULL
	}
}
.parent<-function(x){
	if(!.isRoot(x)){
		return(xmlParent(x));
	}else
	return(NA)
}
.isLeaf<-function(x){
	!.hasChildren(x)
}
.isRoot<-function(x){
	is.null(xmlParent(x))
}
.hasNN<-function(x){
	if(is.null(xmlGetAttr(xpathApply(x,"/Workspace/SampleList/descendant::Sample[1]")[[1]],"nn"))){
		message("Need to do some preprocessing of the XML document tree for the first time. \n This will take a moment.");
	env<-new.env();
	assign("nn",1,envir=env);
	xpathApply(x,"/Workspace/SampleList/descendant::Sample|/Workspace/SampleList/descendant::Population|/Workspace/SampleList/descendant::SampleNode",function(x,e=env){addAttributes(x,"nn"=e[["nn"]]);e[["nn"]]<-e[["nn"]]+1;})
	return(0);	
	}
}

.isBooleanGate.graphNEL<-function(x,y){
#	browser()
	return(get("isBooleanGate",env=nodeData(x@tree,y,"metadata")[[1]]));
}
.isBooleanGate<-function(x){
	p<-xpathApply(x,"./BooleanGate")
	if(length(p)==0)
		return(FALSE)
	else
		return(TRUE)
}
.extractGate<-function(x,env){
	gateType<-setdiff(unlist(xpathApply(x,"./PolygonGate/node()",xmlName),use.names=FALSE),c("ParameterNames","Graph"))
	#gateType<-setdiff(unlist(xpathApply(x,"./node()",xmlName)),c("Graph","Population"));
	
	axes<-tryCatch(xpathApply(x,"./PolygonGate/PolyRect|./PolygonGate/Polygon|./PolygonGate/Ellipse",function(x){
		axes<-c(xmlGetAttr(x,"xAxisName"),xmlGetAttr(x,"yAxisName"));
		axes;
	})[[1]],error=function(y){
		##If it's not a Polygon or PolyRect, it may be one of the following.
		if(gateType=="Range"){
			axes<-xpathApply(x, "./PolygonGate/Range",function(q)xmlGetAttr(q,"xAxisName"))[[1]]
		}
		axes
	})
	nm<-xmlGetAttr(x,"name")
	nn<-xmlGetAttr(x,"nn");
	nm<-paste(nn,nm,sep=".");
	vertices<-tryCatch(t(do.call(cbind,xpathApply(x,"./PolygonGate/PolyRect/Polygon/Vertex|./PolygonGate/Polygon/Polygon/Vertex",function(x){
		vrt<-c(as.numeric(xmlGetAttr(x,"x")),as.numeric(xmlGetAttr(x,"y")))
		vrt
	}))),error=function(y){
		vrt<-tryCatch(t(do.call(cbind,xpathApply(x,"./PolygonGate/Range//Vertex",function(y){
			vrt<-c(as.numeric(xmlGetAttr(y,"x")))
			vrt
			}))),error=function(y){
				vrt<-t(do.call(cbind,xpathApply(x,"./PolygonGate/Ellipse//Vertex",function(y){
					vrt<-c(as.numeric(xmlGetAttr(y,"x")),as.numeric(xmlGetAttr(y,"y")))
					vrt
				})))
			})
	})
	
	##set a one D gate as a rectangleGate.
	if(gateType=="Range"){
		vertices<-matrix(vertices,ncol=1);
	}
	colnames(vertices)<-axes
	##Get the PnG gain for the two axes.
	gains<-.getGains(x)
	#The keywords may or may not have the <>.
	#Best to remove them altogether and match?
	
	gains<-sapply(gsub("<","",gsub(">","",axes)),function(q){
		as.numeric(gains[match(q,gsub(">","",gsub("<","",gains[,1]))),2])
	})
	##Get the current sample name
	attrs<-xpathApply(x,"./ancestor::Sample",xmlAttrs)[[1]];
	sid<-attrs[["sampleID"]];
	compID<-tryCatch(attrs[["compensationID"]],error=function(x)-2);
	if(is.null(compID)){
		##In this case, we need to get more information from the parameters section. See below
		compID<--2;
	}
	# if(compID!=-1&compID!=-2){
		# compnames<-names(.getCompensationMatrices(xmlRoot(x)));
	# }
	# groups<-get("groups",env=get("env",env=globalenv()));
	# samples<-.getSamples(x);
	
	constructTransformations(x,env);
	cal<-get("transformations",env)
	
	
		##cal should now be the required transformation functions (log, or identity), when a compensation matrix is not defined.
		##the transformations should be saved to the metadata or data environment of the hierarchy to save time.

	{
		#TODO FIX calibration table bug
		naxes<-gsub(">","",gsub("<","",axes))
		
v<-sapply(1:length(naxes),function(i)if(any(grepl(naxes[i],names(cal)))){cal[[grep(naxes[i],names(cal))]](vertices[,i])}else{vertices[,i]})
		colnames(v)<-colnames(vertices);
		vertices<-v;rm(v);
	}
	if(gateType=="PolyRect"||gateType=="Polygon"){
		mygate<-polygonGate(filterId=nm[[1]],.gate=t(t(vertices)/gains));
	}else if (gateType=="Range"){		
		mygate<-rectangleGate(filterId=nm[[1]],.gate=t(t(vertices)/gains));
	}else if(gateType=="Ellipse"){
		mygate<-polygonGate(filterId=nm[[1]],.gate=t(t(lapply(list(.ellipseFit(vertices,l=1000)),function(y){colnames(y)<-colnames(vertices);y})[[1]])/gains));
	}
	##Check if the gate is "negated"
	ng<-xpathApply(x,paste("./PolygonGate/",gateType),function(x)xmlGetAttr(x,"negated"))[[1]]
	#print(mygate);
	if(is.null(ng)){
		return(list(mygate,FALSE))
	}else{
		ng<-as.logical(as.numeric(ng));
	}
	return(list(mygate,ng))
	
}
.constructCalTables8.2<-function(cal,x,compID,compnames=NULL){
			if(length(cal)==0){
				#get all parameter names using a calibration.
 				calpars<-unlist(lapply(xpathApply(x,"./ancestor::Sample/Parameter",xmlAttrs),function(y){y[["name"]]["calibrationIndex"%in%names(y)];}),use.names=FALSE)						
 calinds<-na.omit(as.numeric(unlist(lapply(xpathApply(x,"./ancestor::Sample/Parameter",xmlAttrs),function(y){try(y[["calibrationIndex"]]["calibrationIndex"%in%names(y)],silent=TRUE);}),use.names=FALSE)))				
				cal<-sapply(calinds,function(index).getCalibrationTableByIndex(xmlRoot(x),index));
				cal<-lapply(cal,function(x){attr(x,"type")<-"flowJo";x})
				if(!is.null(compnames)&compID!=-2){
				    names(cal)<-trimWhiteSpace(paste(compnames[as.numeric(compID)],calpars))
			    }else{
			        #case where there is no compensation for the sample.
			        names(cal)<-calpars;
			    }
			}
			# =============================================================================================================
			# = Check the lower and upper range of parameters that are linear. We may need to transform the data as well. =
			# =============================================================================================================
			lintrans<-unlist(xpathApply(x,"./ancestor::Sample/Parameter",function(x){if(xmlGetAttr(x,"highValue")[[1]]=="4096"){xmlGetAttr(x,"name")[[1]]}else NULL}),use.names=FALSE)
			if(length(lintrans)!=0){
				lt<-sapply(lintrans,function(y){f<-function(x){x*64};attr(f,"type")<-"gateOnly";f})
				names(lt)<-lintrans;
				if(!any(names(cal)%in%names(lt))){
				    cal<-c(lt,cal)
				}else{
				    cal[names(cal)%in%names(lt)]<-lt
			    }
			}
	return(cal);
}
#Taken from limma (don't want to import and create a dependency)
trimWhiteSpace<-function (x) 
{
    sub("[ \t\n\r]*$", "", sub("^[ \t\n\r]*", "", x))
}

constructTransformations<-function(x,env){
	#TODO need compID
	#need 
	# =======================================
	# = construct transformations code here =
	# =======================================
	attrs<-xpathApply(x,"./ancestor-or-self::Sample",xmlAttrs)[[1]];
	sid<-attrs[["sampleID"]];
	compID<-tryCatch(attrs[["compensationID"]],error=function(x)-2);
	if(is.null(compID)){
		##In this case, we need to get more information from the parameters section. See below
		compID<--2;
	}
	if((compID!=-2)&(compID!=-1)){
		if(exists("transformations",env)){
			cal<-get("transformations",env);
		}else{
			##search for a calibration table name prefixes specific to this compID
			#It may not exist, so construct a table by default.
			#TODO test with Aaron's workspace - where the names don't match ..
			#Currently this doesn't work with Aaron's workspace where the names don't match. 
			#Need a default case.. etc.
			compnames<-names(.getCompensationMatrices(xmlRoot(x)));
			cal<-.getCalibrationTableSearch(xmlRoot(x),compnames[as.numeric(compID)])
			cal<-lapply(cal,function(x){
				at<-attr(x,"type")
				if(length(at)==0)
					attr(x,"type")<-"flowJo";
				x
			})
			#Is it empty?
			if(length(cal)==0){
				#Case where we can't find the transformation we expect.
				#Case where the transformations are not named after the parameters
				#Should we log-transform these dimensions?
				calnames<-unlist(xpathApply(x,"./ancestor::Sample/Parameter",function(x)xmlGetAttr(x,"name")),use.names=FALSE)

				callog<-as.logical(as.numeric(unlist(xpathApply(x,"./ancestor::Sample/Parameter",function(x)xmlGetAttr(x,"log")),use.names=FALSE)))
				#4096, the magic number..
				calrange<-(as.numeric(unlist(xpathApply(x,"./ancestor::Sample/Parameter",function(x)xmlGetAttr(x,"range")),use.names=FALSE))<=4096)
				callog<-callog&calrange

				cal<-list();
				
				#default is identity transform
				cal<-rep(list(function(x){x}),length(calnames))
				names(cal)<-calnames
				for(i in 1:length(cal)){
					attr(cal[[i]],"type")<-"identity"
				}
				#Now log transform what needs to be log transformed
				llen<-length(which(callog))
				
				if(llen!=0){
					for(i in which(callog)){
						cal[[i]]<-function(x){x<-log(x,10);x[is.nan(x)]<-0;x[is.infinite(x)]<-0;x}
						attr(cal[[i]],"type")<-"log";
					}
				}
				##Finally flowJo-specific transform whatever is left.
					
				if(!is.null(.getCalibrationTableNames(x))){
					#Apply flowJo transform
					#Not clear how this should be assigned to the correct parameters
					#I have seen cases with wierd behaviour.
					#this range >=4096 & log=1, means flowJo defined transform.
					calfj<-as.logical(as.numeric(unlist(xpathApply(x,"./ancestor::Sample/Parameter",function(x)xmlGetAttr(x,"log")),use.names=FALSE)))&!calrange
					if(length(which(calfj))!=length(.getCalibrationTableNames(x))){
						#browser()
						if(length(which(calfj))!=0&length(.getCalibrationTableNames(x))==1){
							cn<-names(cal[calfj])
							cal[calfj]<-rep(list(flowWorkspace:::.getCalibrationTable(x,flowWorkspace:::.getCalibrationTableNames(x))),length(cal[calfj])) #apply one to all remaining dimensions
							names(cal[calfj])<-cn;
							for(i in which(calfj))
								attr(cal[[i]],"type")<-"flowJo"
						}else{
							cn<-names(cal[calfj])
							cal[calfj]<-rep(list(flowWorkspace:::.getCalibrationTable(x,flowWorkspace:::.getCalibrationTableNames(x)[1])),length(cal[calfj])) #apply the first one to all remaining dimensions
							#stop("I'm sorry, but the number of flowJo defined transformations doesn't match the number of transformed parameters in .extractGate. Please notify the package authors. Likely your workspace contains a case we haven't dealt with before.")
							names(cal[calfj])<-cn;
							for(i in which(calfj))
								attr(cal[[i]],"type")<-"flowJo"
						}
					}else if(length(calfj!=0)){
						#These are either ordered as in calnames or as in the StainChannelList
						stainnames<-unlist(xpathApply(xmlRoot(x),"/Workspace/StainChannelList/StringArray/String",xmlValue),use.names=FALSE);
						cn<-names(cal[calfj])
						cal[calfj]<-sapply(flowWorkspace:::.getCalibrationTableNames(x),function(y).getCalibrationTable(x,y))[match(calnames[calfj],stainnames)]
						names(cal[calfj])<-cn;
						for(i in which(calfj))
							attr(cal[[i]],"type")<-"flowJo"
					}
				}
			}
			if(.getWorkspaceGeneratedVersion(x)<9){
				cal<-.constructCalTables8.2(cal,x,compID,compnames)
			}
			assign("transformations",cal,env);
		}
	}else if(compID==-1){
		#Usually means acquisition defined compensation matrix
		if(exists("transformations",env)){
			cal<-get("transformations",env);
		}else{	
			#In Aaron's workspace, the names don't necessarily match the calibration tables. I don't know why that is, but we need to deal with it.
			
	r<-unique(unlist(lapply(strsplit(.getCalibrationTableNames(xmlRoot(x)),"<"),function(x)x[1]),use.names=FALSE))[grep("Acquisition-defined",unique(unlist(lapply(strsplit(.getCalibrationTableNames(xmlRoot(x)),"<"),function(x)x[1]),use.names=FALSE)))]
			if(length(r)!=0){	
				cal<-.getCalibrationTableSearch(xmlRoot(x),r)
				for(zz in 1:length(cal)){
					at<-attr(x,"type")
					if(length(at)==0)
					attr(cal[[zz]],"type")<-"flowJo"
				}
			}else{
				#Case where the transformations are not named after the parameters
				#Should we log-transform these dimensions?
				calnames<-unlist(xpathApply(x,"./ancestor::Sample/Parameter",function(x)xmlGetAttr(x,"name")),use.names=FALSE)

				callog<-as.logical(as.numeric(unlist(xpathApply(x,"./ancestor::Sample/Parameter",function(x)xmlGetAttr(x,"log")),use.names=FALSE)))
				#4096, the magic number..
				calrange<-(as.numeric(unlist(xpathApply(x,"./ancestor::Sample/Parameter",function(x)xmlGetAttr(x,"range")),use.names=FALSE))<=4096)
				callog<-callog&calrange

				cal<-list();
				
				#default is identity transform
				cal<-rep(list(function(x){x}),length(calnames))
				names(cal)<-calnames
				for(i in 1:length(cal)){
					attr(cal[[i]],"type")<-"identity"
				}
				#Now log transform what needs to be log transformed
				llen<-length(which(callog))
				
				if(llen!=0){
					for(i in which(callog)){
						cal[[i]]<-function(x){x<-log(x,10);x[is.nan(x)]<-0;x[is.infinite(x)]<-0;x}
						attr(cal[[i]],"type")<-"log";
					}
				}
				##Finally flowJo-specific transform whatever is left.
					
				if(!is.null(.getCalibrationTableNames(x))){
					#Apply flowJo transform
					#Not clear how this should be assigned to the correct parameters
					#I have seen cases with wierd behaviour.
					#this range >=4096 & log=1, means flowJo defined transform.
					calfj<-as.logical(as.numeric(unlist(xpathApply(x,"./ancestor::Sample/Parameter",function(x)xmlGetAttr(x,"log")),use.names=FALSE)))&!calrange
					if(length(which(calfj))!=length(.getCalibrationTableNames(x))){
						#browser();
						if(length(which(calfj))!=0&length(.getCalibrationTableNames(x))==1){
							cn<-names(cal[calfj])
							cal[calfj]<-rep(list(flowWorkspace:::.getCalibrationTable(x,flowWorkspace:::.getCalibrationTableNames(x))),length(cal[calfj])) #apply one to all remaining dimensions
							names(cal[calfj])<-cn;
							for(i in which(calfj))
								attr(cal[[i]],"type")<-"flowJo"
						}else{
							cn<-names(cal[calfj])
							cal[calfj]<-rep(list(flowWorkspace:::.getCalibrationTable(x,flowWorkspace:::.getCalibrationTableNames(x)[1])),length(cal[calfj])) #apply the first one to all remaining dimensions
							#stop("I'm sorry, but the number of flowJo defined transformations doesn't match the number of transformed parameters in .extractGate. Please notify the package authors. Likely your workspace contains a case we haven't dealt with before.")
							names(cal[calfj])<-cn;
							for(i in which(calfj))
								attr(cal[[i]],"type")<-"flowJo"
						}
					}else if(length(calfj!=0)){
						#These are either ordered as in calnames or as in the StainChannelList
						stainnames<-unlist(xpathApply(xmlRoot(x),"/Workspace/StainChannelList/StringArray/String",xmlValue),use.names=FALSE);
						cn<-names(cal[calfj])
						cal[calfj]<-sapply(flowWorkspace:::.getCalibrationTableNames(x),function(y).getCalibrationTable(x,y))[match(calnames[calfj],stainnames)]
						names(cal[calfj])<-cn;
						for(i in which(calfj))
							attr(cal[[i]],"type")<-"flowJo"
					}
				}
			}
			if(.getWorkspaceGeneratedVersion(x)<9){
				cal<-.constructCalTables8.2(cal,x,compID,compnames)
			}
			
			assign("transformations",cal,env);
		}
	}else if(compID==-2){
		##Do we already have the transformations for this gating hierarchy?
		if(exists("transformations",env)){
			cal<-get("transformations",env);
			cal<-lapply(cal,function(x){
				at<-attr(x,"type")
				if(length(at)==0){
					attr(x,"type")<-"flowJo"
				}
				x
			})
		}else{
			#Should we log-transform these dimensions?
			calnames<-unlist(xpathApply(x,"./ancestor::Sample/Parameter",function(x)xmlGetAttr(x,"name")),use.names=FALSE)
			
			callog<-as.logical(as.numeric(unlist(xpathApply(x,"./ancestor::Sample/Parameter",function(x)xmlGetAttr(x,"log")),use.names=FALSE)))
			#4096, the magic number..
			calrange<-(as.numeric(unlist(xpathApply(x,"./ancestor::Sample/Parameter",function(x)xmlGetAttr(x,"range")),use.names=FALSE))<=4096)
			callog<-callog&calrange
			
			cal<-list();
			#Probably need to do something here for 8.2 flowJo workspaces.
			#Yes we do! It's broken!
			
			if(.getWorkspaceGeneratedVersion(x)<9){
				cal<-.constructCalTables8.2(cal,x,compID)
			}else
			{
				#identity transform by default
				cal<-rep(list(function(x){x}),length(calnames))
				names(cal)<-calnames
				for(i in 1:length(cal)){
					attr(cal[[i]],"type")<-"identity"
				}
				#Now log transform what needs to be log transformed
				llen<-length(which(callog))
				
				if(llen!=0){
					for(i in which(callog)){
						cal[[i]]<-function(x){x<-log(x,10);x[is.nan(x)]<-0;x[is.infinite(x)]<-0;x}
						attr(cal[[i]],"type")<-"log";
					}
				}
				##Finally flowJo-specific transform whatever is left.
					
				if(!is.null(.getCalibrationTableNames(x))){
					#Apply flowJo transform
					#Not clear how this should be assigned to the correct parameters
					#I have seen cases with wierd behaviour.
					#this range >=4096 & log=1, means flowJo defined transform.
					calfj<-as.logical(as.numeric(unlist(xpathApply(x,"./ancestor::Sample/Parameter",function(x)xmlGetAttr(x,"log")),use.names=FALSE)))&!calrange
					if(length(which(calfj))!=length(.getCalibrationTableNames(x))){
						#browser();
						if(length(which(calfj))!=0&length(.getCalibrationTableNames(x))==1){
							cn<-names(cal[calfj])
							cal[calfj]<-rep(list(flowWorkspace:::.getCalibrationTable(x,flowWorkspace:::.getCalibrationTableNames(x))),length(cal[calfj])) #apply one to all remaining dimensions
							names(cal[calfj])<-cn;
							for(i in which(calfj))
								attr(cal[[i]],"type")<-"flowJo"
						}else{
							cn<-names(cal[calfj])
							cal[calfj]<-rep(list(flowWorkspace:::.getCalibrationTable(x,flowWorkspace:::.getCalibrationTableNames(x)[1])),length(cal[calfj])) #apply the first one to all remaining dimensions
							names(cal[calfj])<-cn;
							for(i in which(calfj))
								attr(cal[[i]],"type")<-"flowJo"
						}
					}else if(length(calfj!=0)){
						#These are either ordered as in calnames or as in the StainChannelList
						stainnames<-unlist(xpathApply(xmlRoot(x),"/Workspace/StainChannelList/StringArray/String",xmlValue),use.names=FALSE);
						cn<-names(cal[calfj])
						cal[calfj]<-sapply(flowWorkspace:::.getCalibrationTableNames(x),function(y).getCalibrationTable(x,y))[match(calnames[calfj],stainnames)]
						names(cal[calfj])<-cn;
						for(i in which(calfj))
							attr(cal[[i]],"type")<-"flowJo"
					}
				}
			}
			
			assign("transformations",cal,env);
		}
		# =========================================
		# = End of code that builds the trasforms =
		# =========================================
		}else{
			stop("File doesn't have a compensation matrix identified. I'm sorry but we don't support this yet. Contact the package maintainer, your workspace xml file has structure that we want to support, but don't yet.")
		}
}
# ===============================================================================
# = Return the version string of the flowJo version that generated the XML file =
# ===============================================================================
.getFlowJoVersion<-function(x){
	as.character(xpathApply(x,"/Workspace",function(x)xmlGetAttr(x,"flowJoVersion"))[[1]]);
}
.getWorkspaceGeneratedVersion<-function(x){
    ch<-as.character(xpathApply(x,"/Workspace",function(x)xmlGetAttr(x,"versionList"))[[1]]);
    min(na.omit(as.numeric(sapply(gsub("Pre ","",strsplit(ch,";")[[1]]),function(x)strsplit(x,"\\.")[[1]][1]))))
}

setMethod("getSamples","flowJoWorkspace",function(x){
	.getSamples(x@doc)
})
setMethod("getSamples","GatingSet",function(x,isFullPath=FALSE){
	as.vector(unlist(lapply(x,function(y){
					getSample(y,isFullPath)
	}),use.names=FALSE))
})
setMethod("getSample","GatingHierarchy",function(x,isFullPath=FALSE){
			ifelse(isFullPath,file.path(x@dataPath,x@name),x@name)
								
		})
setMethod("getSample","graphNEL",function(x){
			x@nodeData@defaults$data$sampleName
		})

setMethod("getSampleGroups","flowJoWorkspace",function(x){
	.getSampleGroups(x@doc)
})

.getSampleGroups<-function(x,win=FALSE){
	if(!win){
		do.call(rbind,xpathApply(x,"/Workspace/Groups/GroupNode",function(x){
			gid<-c(xmlGetAttr(x,"name"),xmlGetAttr(x,"groupID"));
			sid<-do.call(c,xpathApply(x,".//SampleRef",function(x){
				as.numeric(xmlGetAttr(x,"sampleID"))
			}))
			if(is.null(sid)){
			    sid<-NA;
			}
			groups<-na.omit(data.frame(groupName=gid[[1]],groupID=as.numeric(gid[2]),sampleID=as.numeric(sid)));
		}))
	}else{
		do.call(rbind,xpathApply(x,"/Workspace/Groups/GroupNode",function(x){
			gid<-c(xmlGetAttr(x,"name"),xmlGetAttr(x,"groupID"));
			sid<-do.call(c,xpathApply(x,".//SampleRef",function(x){
				as.numeric(xmlGetAttr(x,"sampleID",default=NA))
			}))
			if(is.null(sid)==0){
				sid<-NA;
			}
			groups<-na.omit(data.frame(groupName=gid[[1]],groupID=as.numeric(gid[2]),sampleID=as.numeric(sid)));
		}))
	}
}

.flowJoTransform<-function(dataenv,cal){
	assign("axis.labels",list(),env=dataenv);
	#this should save some memory
	for (i in 1:dim(get("data",dataenv))[2]){
		#browser();
		#added gsub
		#j<-grep(as.vector(parameters((get("data",dataenv)))@data$name)[i],names(cal));
		j<-grep(gsub(">","",gsub("<","",as.vector(parameters((get("data", dataenv)))@data$name)[i])),names(cal))
		if(length(j)!=0){
			#transform the data only if it's appropriate
			if(attr(cal[[j]],"type")!="gateOnly"){
				assign("tmp",cal[[j]](get("data",dataenv)@exprs[,i]),dataenv)
				assign("i",i,dataenv)
				eval(expression(data@exprs[,i]<-tmp),envir=dataenv)
			}
		}
	}
	datarange<-sapply(1:dim(range(get("data",dataenv)))[2],function(i){
		#added gsub
		j<-grep(gsub(">","",gsub("<","",names(range(get("data",dataenv)))))[i],names(cal));
		if(length(j)!=0){
			rw<-range(get("data",dataenv))[,i];
			if(attr(cal[[j]],"type")!="gateOnly"){
				r<-cal[[j]](c(rw))
			}else{
				r<-rw
			}
			###An unfortunate hack. If we use the log transformation, then negative values are undefined, so
			##We'll test the transformed range for NaN and convert to zero.
			r[is.nan(r)]<-0;
			###Is this transformed?
			if(all(rw==r)){
				#No transformation
				raw<-seq(r[1],r[2],by=(r[2]-r[1])/10)
				signif(raw,2)
				pos<-raw;
			}else{
				#based on the range
				#Inverse transform;
				f<-splinefun(cal[[j]](seq(rw[1],rw[2],l=100000)),seq(rw[[1]],rw[[2]],l=100000),method="natural")
				raw<-signif(f(seq(r[1],r[2],l=20)),2);
				pos<-signif(cal[[j]](raw),2)
			}
			assign("i",i,dataenv)
			assign("raw",raw,dataenv);
			assign("pos",pos,dataenv);
			eval(expression(axis.labels[[i]]<-list(label=as.character(raw),at=pos)),envir=dataenv);
			return(r);
		}else{
			range(get("data",dataenv))[,i]
		}
	})
	datarange<-t(rbind(datarange[2,]-datarange[1,],datarange))
	datapar<-parameters(get("data",dataenv));
	datapar@data[,c("range","minRange","maxRange")]<-datarange
	gc(reset=TRUE)
	assign("datapar",datapar,dataenv)
	eval(expression(data@parameters<-datapar),envir=dataenv)
	gc(reset=TRUE)
}

##This function should return all the calibration vectors associated with a single prefix name.
.getCalibrationTableSearch<-function(doc,term){
	nms<-.getCalibrationTableNames(doc)[grep(term,.getCalibrationTableNames(doc))]
 	trange<-sapply(nms,function(i).getCalibrationTable(doc,i))
	names(trange)<-nms;
	trange;
}

.getSamples<-function(x,win=FALSE){
	lastwarn<-options("warn")[[1]]
	options("warn"=-1)
	top<-xmlRoot(x)
	s<-do.call(rbind,xpathApply(top,"/Workspace/SampleList/Sample/SampleNode",function(x){
		attrs<-xmlAttrs(x);
	data.frame(tryCatch(as.numeric(attrs[["sampleID"]]),error=function(x)NA),tryCatch(attrs[["name"]],error=function(x)NA),tryCatch(as.numeric(attrs[["count"]]),error=function(x)NA))
		}))
		if(!win){
			cid<-as.numeric(paste(xpathApply(top,"/Workspace/SampleList/Sample",function(x)xmlGetAttr(x,"compensationID"))))
			pop.counts<-as.numeric(unlist(lapply(xpathApply(top,"/Workspace/SampleList/Sample"),function(x)xpathApply(x,"count(descendant::Population)")),use.names=FALSE))
			s<-data.frame(s,cid,pop.counts)
			colnames(s)<-c("sampleID","name","count","compID","pop.counts");
		}else{
			##Code for flowJo windows 1.6 xml
			#No compensation ID for windows. Use name
			colnames(s)<-c("sampleID","name","count");
		}
		s[,2]<-as.character(s[,2])
		options("warn"=lastwarn);
		s
}
.trimWhiteSpace<-function (x) 
{
	###Taken from the limma package.
    sub("[ \t\n\r]*$", "", sub("^[ \t\n\r]*", "", x))
}

setMethod("getCompensationMatrices","flowJoWorkspace",function(x){
	.getCompensationMatrices(x@doc);
})

## choose the correct transformation based on the compensation ID. If it's -2, we check the Parameters section for the sample.
setMethod("getTransformations","flowJoWorkspace",function(x){
	nms<-.getCalibrationTableNames(x@doc)
	u<-as.list(unique(unlist(lapply(sapply(nms,function(y)strsplit(y,"<")),function(y).trimWhiteSpace(y[1])),use.names=FALSE)))
	T<-lapply(u,function(y).getCalibrationTableSearch(x@doc,y))
	names(T)<-u
	return(T)
})

.getCompensationMatrices<-function(z){
	top<-xmlRoot(z);
	matrices<-xpathApply(top,"/Workspace/CompensationMatrices/CompensationMatrix",function(x)xmlAttrs(x)[["name"]]);
	cmats<-lapply(matrices,function(mat){
	cmat<-as.numeric(unlist(xpathApply(top,paste("/Workspace/CompensationMatrices/CompensationMatrix[@name='",mat,"']/Channel/ChannelValue",sep=""),xmlGetAttr,"value"),use.names=FALSE))
	d<-sqrt(length(cmat));
	cmat<-matrix(cmat,d,byrow=TRUE)
	colnames(cmat)<-matrix((unlist(xpathApply(top,paste("/Workspace/CompensationMatrices/CompensationMatrix[@name='",mat,"']/Channel/ChannelValue",sep=""),xmlGetAttr,"name"),use.names=FALSE)),byrow=TRUE,d)[1,]
	rownames(cmat)<-matrix((unlist(xpathApply(top,paste("/Workspace/CompensationMatrices/CompensationMatrix[@name='",mat,"']/Channel/ChannelValue",sep=""),xmlGetAttr,"name"),use.names=FALSE)),byrow=TRUE,d)[1,]
	cmat;
	})
	names(cmats)<-matrices;
	cmats;
}
.getStainChannels<-function(x){
	top<-xmlRoot(x)
	channels<-xpathApply(top,"/Workspace/StainChannelList/StringArray/String",xmlValue);
	channels<-unlist(channels,use.names=FALSE);
	channels;
}



.getCalibrationTableNames<-function(x){
	top<-xmlRoot(x)
	tblnames<-xpathApply(top,"/Workspace/CalibrationTables/node()",function(x)xmlGetAttr(x,"name"))
	unlist(tblnames,use.names=FALSE);
}

.getCalibrationTable<-function(x,name){
	top<-xmlRoot(x)
	if(inherits(name,"character")&length(name)==1){
		tbl<-xpathApply(top,paste("/Workspace/CalibrationTables/Table[@name='",name,"']",sep=""),xmlValue)
		tbl<-strsplit(gsub("\n","",tbl[[1]]),",")[[1]]
		#tbl<-ecdf(t(matrix(as.numeric(tbl),2))[,2])
		tbl<-splinefun(t(matrix(as.double(tbl),2))[,2:1],method="natural")
	}else{
		stop("Invalid name argument");
	}
	tbl;
}
.getCalibrationTableByIndex<-function(x,ind){
	top<-xmlRoot(x)
		tbl<-xpathApply(top,paste("/Workspace/CalibrationTables/Table[",ind,"]",sep=""),xmlValue)
		tbl<-strsplit(gsub("\n","",tbl[[1]]),",")[[1]]
		#tbl<-ecdf(t(matrix(as.numeric(tbl),2))[,2])
		tbl<-splinefun(t(matrix(as.double(tbl),2))[,2:1],method="natural")
	tbl;
}
.getCalibrationTableByIndex_inverse<-function(x,ind){
	top<-xmlRoot(x)
		tbl<-xpathApply(top,paste("/Workspace/CalibrationTables/Table[",ind,"]",sep=""),xmlValue)
		tbl<-strsplit(gsub("\n","",tbl[[1]]),",")[[1]]
		#tbl<-ecdf(t(matrix(as.numeric(tbl),2))[,2])
		tbl<-splinefun(t(matrix(as.double(tbl),2))[,1:2],method="natural")
	tbl;
}

#Function that returns the dimension specific transformation (from transformed space to raw intensity space)
#meant to be used for writing out gates to XML for flowJo to read.
.getCalibrationTable_inverse<-function(x,name){
	top<-xmlRoot(x)
	if(inherits(name,"character")&length(name)==1){
		tbl<-xpathApply(top,paste("/Workspace/CalibrationTables/Table[@name='",name,"']",sep=""),xmlValue)
		tbl<-strsplit(gsub("\n","",tbl[[1]]),",")[[1]]
		#tbl<-ecdf(t(matrix(as.numeric(tbl),2))[,2])
		tbl<-splinefun(t(matrix(as.double(tbl),2))[,1:2],method="natural")
	}else{
		stop("Invalid name argument");
	}
	tbl;
}

#TODO: 
# define what old XML is in terms of FlowJo versions.
# there's some kind of transformation that either needs to occur on the range values, or be sent 
# with the gate XML.  Otherwise, this doesn't match (at all) the FlowJo read in to create the flowWorkspace
.rectangleGateToOldFlowJoXML <- function(gate){
    gate_node <- NULL
    if(length(gate@min) == 1){
	    # building the "Range" node from the bottom up
	    vertices <- vector(mode = "list", length = 2)
		# the "as.character" conversion will produce 15 significant digits.
		# Old FlowJo XML appears to have "y" coordinates on these "Range" gates.  They are equal for both vertices.
        vertices[[1]] <- newXMLNode(name = "Vertex", attrs = list(x = as.character(gate@min), y = "0.0"))
		vertices[[2]] <- newXMLNode(name = "Vertex", attrs = list(x = as.character(gate@max), y = "0.0"))
		polygon <- newXMLNode(name = "Polygon", .children = list(vertices))
		range_name <- gate@filterId
		range_xAxisName <- gate@parameters[[1]]@parameters #wrapped in a "unitytransform". what.
        range <- newXMLNode(name = "Range", .children = polygon, attrs = list(name = range_name, xAxisName = range_xAxisName))
		
		# the "PolygonGate" will be comprised of the Range node above, and a ParameterNames.
		# Working backwards again...
		strings <- vector(mode = "list", length = 2)
		strings[[1]] <- newXMLNode(name = "String", text = range_xAxisName)
		strings[[2]] <- newXMLNode(name = "String", text = "")
		string_array <- newXMLNode(name = "StringArray", .children = strings)
		parameter_names <- newXMLNode(name = "ParameterNames", .children = string_array)
		gate_node <- newXMLNode(name = "PolygonGate", .children = list(parameter_names, range))
		
	} else {
	    stop('Only 1-d "Range" gates are currently supported.')
	}
    return(gate_node)	
}
##TODO Method to convert included channel to excluded channels
##TODO Method to convert included gate to excluded gates. (Should be an index of the gates, based on the fjName)
.includedChannel2ExcludedChannel<-function(gs,includedims=NULL){
	dimensions<-parameters(getData(gs[[1]]))@data$name	
	return(setdiff(dimensions,includedims))
}

.includedGate2ExcludedGate<-function(gs,includegates){
	#get the flowJo names
	fjNames<-lapply(nodeData(gs[[1]]@tree),function(x)x$metadata[["fjName"]])
	gnames<-names(fjNames)
	fjNames<-unlist(fjNames,use.names=FALSE)
	#set difference between the included gates and all the rest to get the excluded gates
	
	#get the nodes in breadth first search order
	bfsgates<-lapply(gs,function(y)RBGL::bfs(y@tree)[which(sapply(RBGL::bfs(y@tree),function(x)!flowWorkspace:::.isBooleanGate.graphNEL(y,x)))])
	#get the gates in default order
	gates<-lapply(x,function(y)flowWorkspace:::getNodes(y))
	#reorder the bfsgates so that indices match the order in getNodes
	for(i in seq_along(bfsgates)){
		bfsgates[[i]]<-match(bfsgates[[i]],gates[[i]])
	}
	#combine down to unique gate ids
	bfsgates<-unique(do.call(rbind,bfsgates))
	fjNames<-fjNames[bfsgates]
	excludegates<-setdiff(fjNames,includegates)
	exclude.inds<-bfsgates[fjNames%in%excludegates]
	return(exclude.inds)
}
ExportTSVAnalysis<-function(x=NULL, Keywords=NULL,EXPORT="export"){
    pData(x)<-keyword(x,Keywords)
    dir.create(EXPORT)
    setwd(EXPORT)

    x<-flowWorkspace:::splitGatingSetByNgates(x);
    #STATS
    sts<-NULL
    for(i in 1:length(x)){
        stats<-do.call(rbind,lapply(x[[i]],function(x){stats<-getPopStats(x);rownames(stats)[1]<-"";data.frame(Sample=getSample(x),Population=rownames(stats),Freq_Of_Parent=stats$flowCore.freq,Count=stats$flowCore.count)}))
        sts<-rbind(sts,stats)
    }
    sts$Population<-gsub("^/","",as.character(sts$Population))
    write.table(sts,sep="\t",row.names=F,file="statistics.tsv")
    #Graphs
    graphs<-lapply(x,function(x)lapply(x,function(x){
        s<-getSample(x)
        nds<-getNodes(x)[-1L] #first node is the root, there is no associated gate
        #TODO filter nodes to remove boolean gates
        nds<-nds[!sapply(nds,function(y)flowWorkspace:::.isBooleanGate.graphNEL(x,y))]
        pops<-sapply(nds,function(i)get("fjName",nodeData(x@tree,i,"metadata")[[1]]))
        dir.create(gsub("\\.fcs","",s),showWarnings=FALSE)
        plots<-lapply(as.list(nds),function(y){
            p<-plotGate(x,y,fast=TRUE)
        })
        paths<-do.call(c,lapply(plots,function(i){
            CairoPNG(file="tmp.png",width=300,height=300)
            print(i)
            dev.off();
            md5<-md5sum("tmp.png")
            path<-paste(paste(gsub("\\.fcs","",s),md5,sep="/"),"png",sep=".")
            file.copy(from="tmp.png",to=path)
            file.remove("tmp.png")
            path;
        }))
        graphs<-sapply(nds,function(y)paste(getDimensions(x,y),collapse=":"))
        data.frame(Sample=s,Population=gsub("^/","",pops),Graph=graphs,Path=paths);        
    }))
    graphs<-do.call(rbind,lapply(graphs,function(x)do.call(rbind,x)))
    write.table(graphs,sep="\t",row.names=F,file="graphs.tsv")
    setwd("../");
    invisible();
}
	
